#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import configparser
import os
import pprint
import re
import json
import sys
from random import shuffle

import http.server
import webbrowser
import requests

SCRIPT_VERSION = '0.0.1.0'

CONFIG_PATH = './config.ini'

pp = pprint.PrettyPrinter(indent=4)

class Config(object):

    def __init__(self, path):
        self.path = path

        if not os.path.isfile(path):
            self.createNewConfig()
        else:
            self.read()

    def createNewConfig(self):
        self.cfg = configparser.ConfigParser()

        self.cfg['auth'] = {'app_id': '', 'secret': '', 'port': '8090'}
        self.cfg['token'] = {'token': ''}

        self.write()

    def write(self):
        with open(self.path, 'w') as configfile:
            self.cfg.write(configfile)

    def read(self):
        self.cfg = configparser.ConfigParser()
        self.cfg.read(self.path)
    
    def get(self, section=None, option=None):
        if option is None and section is None:
            return self.getAll()
        elif option is None:
            return self.getSection(section)
        else:
            return self.getOption(section, option)

    def getAll(self):
        data = {}
        for cfg_section in self.cfg.sections():
            data[cfg_section] = {}
            for key, val in self.cfg.items(cfg_section):
                data[cfg_section][key] = val
        return data

    def getSection(self, section):
        data = {}
        for key, val in self.cfg.items(section):
            data[key] = val
        return data

    def getOption(self, section, option):
        return self.cfg.get(section, option)

    def set(self, section, option, value):
        if not self.cfg.has_section(section):
            self.cfg.add_section(section)

        self.cfg.set(section, option, value)
        self.write()

    def sections(self):
        return self.cfg.sections()
        


class DeezerAuth(object):
    urlAuth = 'https://connect.deezer.com/oauth/auth.php?app_id={0}&redirect_uri={1}&perms=basic_access,manage_library'
    urlToken = 'https://connect.deezer.com/oauth/access_token.php?app_id={0}&secret={1}&code={2}&output=json'
    urlRedirect = 'http://localhost:{0}/authfinish'
    urlCheckToken = 'http://api.deezer.com/user/me?access_token={0}'
    user = None

    def getToken(self):
        return self.token
    
    def setParams(self, params, token=''):
        self.port = int(params['port'])
        self.secret = params['secret']
        self.appId = params['app_id']
        self.token = token

    def setToken(self, token):
        self.token = token

    def authorize(self):
        self.fetchCode()
        self.fetchToken()            

    def fetchCode(self):
        redirect = self.urlRedirect.format(self.port)
        webbrowser.open(self.urlAuth.format(self.appId, redirect))
        self.startServer()
        try:
            while True:
                self.server.handle_request()
        except _Authorization as auth:
            self.code = auth.code

    def startServer(self):
        self.server = _AuthorizationServer('localhost', self.port)

    def fetchToken(self):
        url = self.urlToken.format(self.appId, self.secret, self.code)        
        response = json.loads(requests.get(url).text)

        if 'access_token' in response:
            self.token = response['access_token']
        else:
            raise Exception('Cant get token from deezer')

    def checkToken(self):
        url = self.urlCheckToken.format(self.token)
        response = json.loads(requests.get(url).text)

        if 'error' in response:
            return False
        elif 'type' in response and response['type'] == 'user':
            self.user = response
            return True
        else:
            raise Exception('Cant check auth token')

    def fetchUser(self):
        # user fetchig on token check
        if not self.checkToken():
            raise Exception('Cant fetch user info due failed token check')

    def getUser(self):
        if self.user is None:
            self.fetchUser()

        return self.user

class _AuthorizationServer(http.server.HTTPServer):
    def __init__(self, host, port):
        http.server.HTTPServer.__init__(self, (host, port), _AuthorizationHandler)

    # Disable the default error handling.
    def handle_error(self, request, client_address):
        raise

class _AuthorizationHandler(http.server.BaseHTTPRequestHandler):
    def do_GET(self):
        # Read access_token and use an exception to kill the server listening...
        if self.path.startswith('/authfinish?'):
            self.send_response(200)
            self.send_header('Content-Type', 'text/html')
            self.end_headers()
            self.wfile.write(b'<script>close()</script>Thanks! You may now close this window.')
            raise _Authorization(re.search('code=([^&]+)', self.path).group(1))

        else:
            self.send_error(404)

    # Disable the default logging.
    def log_message(self, format, *args):
        pass

class _Authorization(Exception):
    def __init__(self, code):
        self.code = code

class DeezerTool(object):
    baseUrl = 'http://api.deezer.com'
    limit = 1000

    playlists = []
    tracks = []

    def __init__(self, config, auth):
        self.config = config
        self.auth = auth
        self.auth.setParams(config.get('auth'), config.get('token', 'token'))

    def checkAndUpdateToken(self):
        if not self.checkToken():
            self.updateToken()
        return self

    def updateToken(self):
        self.auth.authorize()

        if self.checkToken():
            self.config.set('token', 'token', self.auth.getToken())
        else:
            raise Exception('Cant verify new token')

        return self

    def checkToken(self):
        return self.auth.checkToken()

    def getToken(self):
        return self.config.get('token', 'token')

    def processApiError(self, errorData):
        message = errorData['message']
        print('Error '+str(errorData['code'])+': '+message)
        sys.exit()

    def prepareResponse(self, response, responseType):
        response = json.loads(response.text)

        # if debug:
        #     pp.pprint(response)
        #     sys.exit()

        if 'error' in response:
            return self.processApiError(response['error'])

        if responseType == 'list':
            if 'data' not in response:
                raise Exception('Error occured on request to Deezer api')

            nextPages = []
            if 'next' in response:
                nextPages = self.apiGetStrict(response['next'], 'list')

            return response['data'] + nextPages

        elif responseType == 'single':
            return response

        else:
            raise Exception('Unknown response type "'+responseType+'", it can be one of those: single, list')
           


    def addRequiredParams(self, params):
        if 'access_token' not in params:
            params['access_token'] = self.getToken()
        if 'expires' not in params:
            params['expires'] = 0
        return params


    def apiGet(self, uri, responseType, params = {}):
        params = self.addRequiredParams(params)
        response = requests.get(self.baseUrl + uri, params)
        return self.prepareResponse(response, responseType)

    def apiGetStrict(self, responseType, url):
        response = requests.get(url)
        return self.prepareResponse(response, responseType)

    def apiPost(self, uri, responseType, params={}):
        params = self.addRequiredParams(params)
        response = requests.post(self.baseUrl + uri, params)
        return self.prepareResponse(response, responseType)

    def getPlaylists(self):
        return self.playlists

    def getTracks(self):
        return self.tracks

    def filterPlaylistsByTitle(self, titles):
        self.playlists = [pl for pl in self.playlists if pl['title'] in titles]
        return self

    def findAllPlaylists(self):
        self.playlists = self.apiGet('/user/me/playlists', 'list')
        return self

    def findTracksByPlaylists(self):
        for pl in self.playlists:
            uri = '/playlist/{0}/tracks'.format(pl['id'])
            tracks = self.apiGet(uri, 'list')
            self.tracks += tracks

        return self

    def shuffleTracks(self):
        shuffle(self.tracks)
        return self

    def filterTracksByLimit(self, limit=None):
        if limit is None:
            limit = self.limit

        self.tracks = self.tracks[:limit]
        return self

    def getUser(self):
        return self.auth.getUser()

    def createPlaylist(self, title):
        uri = '/user/{0}/playlists'.format(self.getUser()['id'])
        response = self.apiPost(uri, 'single', {'title': title})
        self.newPlaylistId = response['id']
        return self



if __name__ == '__main__':
    config = Config(CONFIG_PATH)
    auth = DeezerAuth()

    dTool = DeezerTool(config, auth)

    # data = dTool\
    #     .checkAndUpdateToken()\
    #     .findAllPlaylists()\
    #     .filterPlaylistsByTitle(['работа', 'работа 2'])\
    #     .findTracksByPlaylists()\
    #     .shuffleTracks()\
    #     .filterTracksByLimit()\
    #     .getTracks()
    
    # data = dTool\
    #     .checkAndUpdateToken()\
    #     .getUser()
    
    data = dTool\
        .checkAndUpdateToken()\
        .createPlaylist('pl1')

    pp.pprint(data.newPlaylistId)

    # data2 = []
    # counter = 0
    # for item in data:
    #     counter += 1
    #     data2.append({'num':counter, 'artist':item['artist']['name'], 'track':item['title']})

    # pp.pprint(data2)
    