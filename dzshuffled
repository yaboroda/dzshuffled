#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
author:     yaBoroda
github:     https://github.com/yaboroda/dzshuffled
email:      yarboroda@gmail.com
"""

import configparser
import os
import pprint
import re
import json
import sys
from random import shuffle
import argparse
from typing import Dict, List, Union

import http.server
import webbrowser
import requests

SCRIPT_VERSION = '0.9.1.0'

if 'DZSHUFFLED_CONFIG_PATH' in os.environ:
    CONFIG_PATH = os.environ['DZSHUFFLED_CONFIG_PATH']
else:
    CONFIG_PATH = os.path.expanduser("~") + "/.config/dzshuffled/config.ini"

DEBUG_MODE = False

pp = pprint.PrettyPrinter(indent=4)

class Config(object):
    """
    manage info from config .ini file
    """

    def __init__(self, path):
        """
        path - path to config file
        """

        self.path = path

        if not os.path.isfile(path):
            self.create_new_config_file()
            print('New config file was created in {}'.format(path))
            sys.exit()
        else:
            self.read()

    def set_up_default_config(self):
        self.cfg['config'] = {'example_config': 'redeclare method set_up_default_config to set up default config'}

    def create_new_config_file(self):
        os.makedirs(os.path.dirname(self.path), exist_ok=True)
        self.cfg = configparser.ConfigParser()
        self.set_up_default_config()
        self.write()

    def write(self):
        """
        write current config to file
        """

        with open(self.path, 'w') as configfile:
            self.cfg.write(configfile)

    def read(self):
        """
        read config from file, replacing current data
        """

        self.cfg = configparser.ConfigParser()
        self.cfg.read(self.path)
    
    def get(self, section=None, option=None):
        """
        get info from config
        if option is None, will return section as dictionary
        if section is None, will return whole config as dictionary
        """

        if option is None and section is None:
            return self.get_all()
        elif option is None:
            return self.get_section(section)
        else:
            return self.get_option(section, option)

    def get_all(self):
        """
        will return whole config as dictionary
        """

        data = {}
        for cfg_section in self.cfg.sections():
            data[cfg_section] = {}
            for key, val in self.cfg.items(cfg_section):
                data[cfg_section][key] = val
        return data

    def get_section(self, section):
        """
        will return section data as dictionary
        """
        data = {}
        for key, val in self.cfg.items(section):
            data[key] = val
        return data

    def get_option(self, section, option):
        """
        will return value of config option in section
        """
        return self.cfg.get(section, option)

    def set(self, section, option, value):
        """
        set option value and write change to config file
        """
        if not self.cfg.has_section(section):
            self.cfg.add_section(section)

        self.cfg.set(section, option, value)
        self.write()

    def sections(self):
        """
        get list of sections in config
        """
        return self.cfg.sections()


class DeezerConfig(Config):

    def set_up_default_config(self):
        self.cfg['auth'] = {'app_id': '', 'secret': '', 'port': '8090'}
        self.cfg['token'] = {'token': ''}
        self.cfg['pl_example'] = {'title': 'Example shuffled playlist', 'type': 'shuffled', 'source': 'playlist 1, playlist 2', 'limit': 1000}


class DeezerAuth(object):
    URL_AUTH = 'https://connect.deezer.com/oauth/auth.php?app_id={0}&redirect_uri={1}&perms=basic_access,manage_library,delete_library'
    ULR_TOKEN = 'https://connect.deezer.com/oauth/access_token.php?app_id={0}&secret={1}&code={2}&output=json'
    URL_REDIRECT = 'http://localhost:{0}/authfinish'
    URL_CHECK_TOKEN = 'http://api.deezer.com/user/me?access_token={0}'

    def __init__(self):
        self.user = None
        self.token = ''

    def get_token(self):
        return self.token
    
    def set_params(self, params:Dict, token=''):
        """
        port - on this port will be working web server to recieve auth answer
        secret - secret of your Deezer app
        app_id - id of your Deezer app
        token - auth token, if empty or invalid, it will be fetched
        """
        self.port = int(params['port'])
        self.secret = params['secret']
        self.app_id = params['app_id']
        self.token = token

    def set_token(self, token):
        self.token = token

    def authorize(self):
        """
        fetch auth app code, asking you for permission
        then fetch temporary auth token
        """
        if not self.app_id or not self.secret:
            raise DeezerAuthException('You cant get authorization token without app_id and secret. Fill it in config file or write there valid token.')
        self.fetch_code()
        self.fetch_token()            

    def fetch_code(self):
        """
        fetch auth app code, asking you for permission
        """
        redirect = self.URL_REDIRECT.format(self.port)
        webbrowser.open(self.URL_AUTH.format(self.app_id, redirect))
        self.start_server()
        try:
            while True:
                self.server.handle_request()
        except _Authorization as auth:
            self.code = auth.code

    def start_server(self):
        """
        start web server to listen for response with auth code
        """
        self.server = _AuthorizationServer('localhost', self.port)

    def fetch_token(self):
        """
        fetch temporary auth token if you has auth code
        """
        url = self.ULR_TOKEN.format(self.app_id, self.secret, self.code)        
        response = json.loads(requests.get(url).text)

        if 'access_token' in response:
            self.token = response['access_token']
        else:
            raise DeezerAuthException('Cant get token from deezer')

    def check_token(self) -> bool:
        """
        check auth token, fetching user info
        """
        url = self.URL_CHECK_TOKEN.format(self.token)
        response = json.loads(requests.get(url).text)

        if 'error' in response:
            return False
        elif 'type' in response and response['type'] == 'user':
            self.user = response
            return True
        else:
            raise DeezerAuthException('Cant check auth token')

    def fetch_user(self):
        # user fetchig on token check
        if not self.check_token():
            raise DeezerAuthException('Cant fetch user info due failed token check')

    def get_user(self) -> Dict:
        if self.user is None:
            self.fetch_user()

        return self.user

class _AuthorizationServer(http.server.HTTPServer):
    def __init__(self, host, port):
        http.server.HTTPServer.__init__(self, (host, port), _AuthorizationHandler)

    # Disable the default error handling.
    def handle_error(self, request, client_address):
        raise

class _AuthorizationHandler(http.server.BaseHTTPRequestHandler):
    def do_GET(self):
        # Read access_token and use an exception to kill the server listening...
        if self.path.startswith('/authfinish?'):
            self.send_response(200)
            self.send_header('Content-Type', 'text/html')
            self.end_headers()
            self.wfile.write(b'<script>close()</script>Thanks! You may now close this window.')
            raise _Authorization(re.search('code=([^&]+)', self.path).group(1))

        else:
            self.send_error(404)

    # Disable the default logging.
    def log_message(self, format, *args):
        pass

class DeezerTool(object):
    BASE_URL = 'http://api.deezer.com'
    VALID_SCENARIO_TYPES = ['shuffled']
    LIMIT_TRACKS = 1000
    LIMIT_RESULTS_PER_REQUEST = 500
    LIMIT_ITEMS_DELETE_PER_ONE_REQUEST = 500

    def __init__(self, config:DeezerConfig, auth:DeezerAuth):
        self.playlists = []
        self.tracks = []
        self.config = config
        self.auth = auth
        self.auth.set_params(config.get('auth'), config.get('token', 'token'))

    def check_and_update_token(self) -> 'DeezerTool':
        if not self.check_token():
            self.update_token()
        return self

    def update_token(self) -> 'DeezerTool':
        """
        authorize in Deezer and write new token in config file
        """
        self.auth.authorize()

        if self.check_token():
            self.config.set('token', 'token', self.auth.get_token())
        else:
            raise DeezerToolException('Cant verify new token')

        return self

    def check_token(self) -> bool:
        return self.auth.check_token()

    def get_token(self) -> str:
        return self.config.get('token', 'token')

    def process_api_error(self, error_data:Dict):
        """
        raise exception by error sesponse from Deezer
        """
        code = error_data['code'] if 'code' in error_data else None
        raise DeezerApiError(error_data['message'], code)

    def prepare_response(self, response, response_type:str) -> Union[bool, Dict]:
        """
        get data from response object
        response_type - 'list' or 'single'
        if 'list' then getting all paginated data with additional requests
        """
        response = json.loads(response.text)
        
        if isinstance(response, bool):
            return response

        if 'error' in response:
            return self.process_api_error(response['error'])

        if response_type == 'list':
            if 'data' not in response:
                raise DeezerToolException('Error occured on request to Deezer api')

            nextPages = []
            if 'next' in response:
                nextPages = self.api_get_strict(response['next'], 'list')

            return response['data'] + nextPages

        elif response_type == 'single':
            return response

        else:
            raise DeezerToolException('Unknown response type "'+response_type+'", it can be either single or list')
           


    def add_required_params(self, params:Dict) -> Dict:
        """
        add token and limit to requests param
        """
        if 'access_token' not in params:
            params['access_token'] = self.get_token()

        if 'limit' not in params:
            params['limit'] = self.LIMIT_RESULTS_PER_REQUEST

        return params


    def api_get(self, uri:str, response_type:str, params:Dict = {}) -> Union[bool, Dict]:
        """
        send GET request to Deezer API
        uri - address without domain
        response_type - 'single' or 'list'
        """
        params = self.add_required_params(params)
        response = requests.get(self.BASE_URL + uri, params)
        return self.prepare_response(response, response_type)

    def api_get_strict(self, url:str, response_type:str) -> Union[bool, Dict]:
        """
        send GET request strictly by url, wich include domain and all parameters
        response_type - 'single' or 'list'
        """
        response = requests.get(url)
        return self.prepare_response(response, response_type)

    def api_post(self, uri:str, response_type:str, params:Dict={}) -> Union[bool, Dict]:
        """
        send POST request to Deezer API
        uri - address without domain
        response_type - 'single' or 'list'
        """
        params = self.add_required_params(params)
        response = requests.post(self.BASE_URL + uri, params)
        return self.prepare_response(response, response_type)

    def api_delete(self, uri, response_type, params={}) -> Union[bool, Dict]:
        """
        send DELETE request to Deezer API
        uri - address without domain
        response_type - 'single' or 'list'
        """
        params = self.add_required_params(params)
        uri += '?access_token={0}'.format(params.pop('access_token'))

        for p, val in params.items():
            uri += '&{0}={1}'.format(p, val)
        
        response = requests.delete(self.BASE_URL + uri)
        return self.prepare_response(response, response_type)

    def get_playlists(self) -> List:
        """
        get playlists info stored in self.playlists
        """
        return self.playlists

    def get_tracks(self) -> List:
        """
        get tracks info stored in self.tracks
        """
        return self.tracks

    def filter_playlists_by_titles(self, titles:Union[List, str]) -> 'DeezerTool':
        """
        remove from self.playlisits those which titles does not listed in `titles` param
        """
        if isinstance(titles, str):
            titles = [titles]

        self.playlists = [pl for pl in self.playlists if pl['title'] in titles]
        return self

    def find_all_play_lists(self) -> 'DeezerTool':
        """
        fetch info about all playlists and store it in self.playlists
        """
        self.playlists = self.api_get('/user/me/playlists', 'list')
        return self

    def find_tracks_by_playlists(self) -> 'DeezerTool':
        """
        fetch info about all tracks, listed in playlists from self.playlists
        and store it in self.tracks
        """
        self.tracks = []
        for pl in self.playlists:
            uri = '/playlist/{0}/tracks'.format(pl['id'])
            tracks = self.api_get(uri, 'list')
            self.tracks += tracks

        return self

    def shuffle_tracks(self) -> 'DeezerTool':
        """
        shuffle self.tracks
        """
        shuffle(self.tracks)
        return self

    def filter_tracks_by_limit(self, limit:int=None) -> 'DeezerTool':
        """
        left only first `limit` items from self.tracks, removing the rest
        if limit is None than limit getting from default value
        """
        if limit is None:
            limit = self.LIMIT_TRACKS

        self.tracks = self.tracks[:limit]
        return self

    def get_user(self) -> Dict:
        """
        get info about current user
        """
        return self.auth.get_user()

    def create_playlist(self, title:str) -> 'DeezerTool':
        """
        create playlist with title `title` in your Deezer library
        """
        uri = '/user/{0}/playlists'.format(self.get_user()['id'])
        response = self.api_post(uri, 'single', {'title': title})
        self.new_playlist_id = response['id']
        return self

    def remove_playlist_by_id(self, id) -> 'DeezerTool':
        """
        remove playlist from your library by id
        it will not warning you or ask, so think carefully
        """
        uri = '/playlist/{0}'.format(id)
        response = self.api_delete(uri, 'single')
        return self

    def purge_playlist_by_id(self, id) -> 'DeezerTool':
        """
        remove all tracks from playlist by id
        it will not warning you or ask, so think carefully
        """
        uri = '/playlist/{0}/tracks'.format(id)
        groups = self.get_string_of_ids_by_groups(self.tracks, self.LIMIT_ITEMS_DELETE_PER_ONE_REQUEST)

        for track_ids in groups:
            response = self.api_delete(uri, 'single', {'songs': track_ids})

    def purge_playlist_by_title(self, title) -> 'DeezerTool':
        """
        remove all tracks from all playlists with this title
        it will not warning you or ask, so think carefully
        """
        (self.find_all_play_lists()
                    .filter_playlists_by_titles(title)
                    .find_tracks_by_playlists())

        for pl in self.playlists:
            self.purge_playlist_by_id(pl['id'])

    def remove_playlist_by_title(self, title) -> 'DeezerTool':
        """
        remove all playlists from your library with this title
        it will not warning you or ask, so think carefully
        """
        self.find_all_play_lists()
        self.filter_playlists_by_titles([title])

        for pl in self.playlists:
            self.remove_playlist_by_id(pl['id'])

        self.playlists = []
        return self

    def add_tracks_to_playlist(self, id) -> bool:
        """
        add tracks from self.tracks to playlist with this id
        """
        uri = '/playlist/{0}/tracks'.format(id)
        track_ids = self.get_string_of_ids(self.tracks)
        response = self.api_post(uri, 'single', {'songs': track_ids})
        return response

    def add_tracks_to_new_playlist(self) -> bool:
        """
        add tracks from self.tracks to playlist that was just created
        (it takes id from self.new_playlist_id)
        """
        return self.add_tracks_to_playlist(self.new_playlist_id)

    def reset_playlist_by_title(self, title) -> 'DeezerTool':
        """
        find playlist by title and remove all tracks from it
        if there is several pl with title, it will remove them all and create one new
        if there is no pl with title, it will create one
        cleared or created playlists id will be stored in self.target_playlist_id
        """

        # find all playlists by title
        self.find_all_play_lists().filter_playlists_by_titles(title)

        # if there is more then one, remove it and create new
        if len(self.playlists) > 1:
            self.remove_playlist_by_title(title)
            self.create_playlist(title)
            self.target_playlist_id = self.new_playlist_id

        # if there is only one, delete all tracks from it
        elif len(self.playlists) == 1:
            self.target_playlist_id = self.playlists[0]['id']
            self.find_tracks_by_playlists()
            self.purge_playlist_by_id(self.target_playlist_id)

        # if there is no one, create new
        else:
            self.create_playlist(title)
            self.target_playlist_id = self.new_playlist_id

        return self

    def reset_shuffled_playlist(self, title:str, source_pls:List, limit:int = None) -> 'DeezerTool':
        """
        create playlist with `title`, if it exests then purge it from tracks,
        then populate it from your playlists wich titles listed in `source_pls`,
        shufflig them before it
        """

        print('Resetting playlist {0}'.format(title))

        # reset playlist and write its id to self.target_playlist_id
        self.reset_playlist_by_title(title)

        # find all tracks from list source_pls, suffle it and cut to limit
        # then shove to target playlist
        self.find_all_play_lists()
        self.filter_playlists_by_titles(source_pls)

        print('Finding all tracks from playlists: '+', '.join([pl['title'] for pl in self.playlists]))

        self.find_tracks_by_playlists()

        tracks_count = len(self.tracks)
        print('Found {0} tracks'.format(str(tracks_count)))

        self.rid_of_double_tracks()
        new_tracks_count = len(self.tracks)
        tracks_count_delta = tracks_count - new_tracks_count

        if tracks_count_delta > 0:
            print('Rid of {0} duplicates, {1} tracks left'.format(tracks_count_delta, new_tracks_count))

        print('Shuffling')
        self.shuffle_tracks()
        self.filter_tracks_by_limit(limit)

        print('Adding {0} tracks to playlist {1}'.format(str(len(self.tracks)), title))
        
        self.add_tracks_to_playlist(self.target_playlist_id)

        print('Done')

        return self

    def get_string_of_ids(self, items_list:List[Dict]) -> str:
        """
        get string of id of items in list
        """
        items_ids = ','.join([ str(item['id']) for item in items_list ])
        return items_ids

    def get_string_of_ids_by_groups(self, items_list:List[Dict], limit:int) -> List[str]:
        """
        get list of strings of id of items in list, splitted by `limit` id in string
        """
        groups = []
        for i in range(0, len(items_list), limit):
            groups.append(self.get_string_of_ids( items_list[i:i+limit] ))

        return groups

    def check_scenario_name_valid(self, scenario_name:str, raise_exception = False) -> bool:
        """
        check if scenario_name is valid name for scenario
        if raise_exception is True, then instad of returning False it will raise exception
        """
        check = bool(re.search('^pl_', scenario_name))

        if raise_exception and not check:
            raise DeezerToolException('Invalid scenario name: "{}"'.format(scenario_name))
        else:
            return check

    def exec_scenario(self, scenario) -> 'DeezerTool':
        """
        execute scenrio from config by its name
        """
        self.check_scenario_name_valid(scenario, True)
        
        scenario_config = self.config.get(scenario)

        if 'type' not in scenario_config or not scenario_config['type'] or scenario_config['type'] not in self.VALID_SCENARIO_TYPES:
            raise DeezerToolException('Scenario config section must contain valid type option')

        if 'title' not in scenario_config or not scenario_config['title']:
            raise DeezerToolException('Scenario config section must contain title option')
        else:
            title = scenario_config['title']

        if 'source' not in scenario_config or not scenario_config['source']:
            raise DeezerToolException('Scenario config section must contain source option')
        else:
            source_pls = scenario_config['source'].split(', ')
        
        limit = int(scenario_config['limit']) if 'limit' in scenario_config else None

        self.reset_shuffled_playlist(title, source_pls, limit)

        return self

    def get_list_of_scenarios(self) -> List:
        """
        get list of scenarios names from config
        """
        scenarios = [key for key, val in self.config.get().items() if self.check_scenario_name_valid(key)]

        return scenarios

    def get_scenario_name_by_index(self, n:int) -> str:
        """
        get scenarios name by it order number in config 
        """
        scenarios = self.get_list_of_scenarios()
        if len(scenarios) > n:
            return scenarios[n]
        else:
            raise DeezerToolException('There is no scenario number {0}. Max number is {1}'.format(n, len(scenarios)-1))

    def get_scenario_index_by_name(self, scenario) -> int:
        """
        get scenario order number by it name
        """
        scenarios = self.get_list_of_scenarios()
        if scenario in scenarios:
            return scenarios.index(scenario)
        else:
            raise DeezerToolException('There is no scenario "{}"'.format(scenario))

    def get_scenario_config(self, scenario:str) -> Dict:
        if self.check_scenario_name_valid(scenario, True):
            return self.config.get(scenario)

    def rid_of_double_tracks(self) -> 'DeezerTool':
        """
        remove duplicated items from self.tracks
        """
        self.tracks = self.rid_of_doubles_in_list_of_dict(self.tracks)
        return self

    def rid_of_doubles_in_list_of_dict(self, list_of_dict:List[Dict], field:str = 'id'):
        """
        remove duplicates from `list_of_dict`, comparig them by `field`
        """
        new_list = []
        unique_vals = []

        for el in list_of_dict:
            if el[field] not in unique_vals:
                unique_vals.append(el[field])
                new_list.append(el)

        return new_list

class _Authorization(Exception):
    """
    this exception will be raised on successfull authorization
    """
    def __init__(self, code):
        self.code = code

class DeezerApiError(Exception):
    def __init__(self, message, code):
        exc_message = 'Deezer API error {1}: {0}'.format(message, 'code '+str(code) if code else '')
        super(DeezerApiError, self).__init__(exc_message)

class DeezerToolException(Exception):
    pass

class DeezerAuthException(Exception):
    pass

def handle_exception_output(e, template='{0}'):
    """
    if not DEBUG_MODE swallow tracing exception, output only message
    """
    if not DEBUG_MODE:
        print(template.format(e))
    else:
        raise e

def print_help_and_exit(parser):
    parser.print_help()
    sys.exit()

def build_cli_parser():
    parser = argparse.ArgumentParser(
            description = 'This script will create playlist in your Deezer library consisting of shuffled tracks from your other playlists. Pass scenario name or number to create playlist from it. Pass -l or -lv to see all scenarios. Scenarios sets up in config wich by default in ~/.config/dzshuffled/config.ini but you can reassign it with DZSHUFFLED_CONFIG_PATH environment variable.'
        )

    parser.add_argument('scenario',
            metavar = 'SCENARIO',
            nargs='?', 
            const='', 
            default='',
            help = 'name or number of scenario. Pass -l argument to see full list'
        )

    parser.add_argument('-l', '--list',
            action = 'store_const', 
            const = True,
            help = 'show full list of scenarios to create playlist from, pass -v param to show info about them'
        )

    parser.add_argument('-v', '--verbous',
            action = 'store_const', 
            const = True,
            help = 'if called with argument -l, show info about listed scenarios'
        )

    parser.add_argument('-i', '--info', 
            action = 'store_const', 
            const = True,
            help = 'show info about selected scenario but not do anithing'
        )

    parser.add_argument('--version', 
            action = 'store_const', 
            const = True,
            help = 'show script version'
        )

    return parser

def print_info_about_scenario(number, name, data = None):
    if data:
        print('[{0}] {1}'.format(number, name))
        pp.pprint(data)
    else:
        print('[{0}] {1}'.format(number, name))

def print_list_scenarios(dz_tool, verbosity=None):
    scenarios = dz_tool.get_list_of_scenarios()
    for i in range(len(scenarios)):
        if verbosity:
            print_info_about_scenario(i, scenarios[i], dz_tool.get_scenario_config(scenarios[i]))
        else:
            print_info_about_scenario(i, scenarios[i])

def process_cli_scenario_call(scenario_input, dz_tool, info_flag=None):
    if scenario_input.isnumeric():
        scenario_index = int(scenario_input)
        scenario_name = dz_tool.get_scenario_name_by_index(scenario_index)
    else:
        scenario_name = scenario_input
        scenario_index = dz_tool.get_scenario_index_by_name(scenario_name)

    if info_flag:
        print_info_about_scenario(scenario_index, scenario_name, dz_tool.get_scenario_config(scenario_name))
    else:
        dz_tool.check_and_update_token()
        dz_tool.exec_scenario(scenario_name)

if __name__ == '__main__':

    # DEBUG_MODE = True

    try:
        config = DeezerConfig(CONFIG_PATH)
        parser = build_cli_parser()
        args = parser.parse_args()

        if args.version:
            print('version: {0}'.format(SCRIPT_VERSION))
            sys.exit()

        if not args.scenario and not args.list:
            print_help_and_exit(parser)        

        auth = DeezerAuth()
        dz_tool = DeezerTool(config, auth)  

        if args.list:
            print_list_scenarios(dz_tool, args.verbous)
            sys.exit()

        if args.scenario:
            process_cli_scenario_call(args.scenario, dz_tool, args.info)
            sys.exit()

    except DeezerApiError as e:
        handle_exception_output(e)
    except Exception as e:
        handle_exception_output(e, 'Error: {0}')