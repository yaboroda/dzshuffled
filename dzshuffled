#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import configparser
import os
import pprint
import re
import json
import sys

import http.server
import webbrowser
import requests

SCRIPT_VERSION = '0.0.1.0'

CONFIG_PATH = './config.ini'

pp = pprint.PrettyPrinter(indent=4)

class Config(object):

    def __init__(self, path):
        self.path = path

        if not os.path.isfile(path):
            self.createNewConfig()
        else:
            self.read()

    def createNewConfig(self):
        self.cfg = configparser.ConfigParser()

        self.cfg['auth'] = {'app_id': '', 'secret': '', 'port': '8090'}
        self.cfg['token'] = {'token': ''}

        self.write()

    def write(self):
        with open(self.path, 'w') as configfile:
            self.cfg.write(configfile)

    def read(self):
        self.cfg = configparser.ConfigParser()
        self.cfg.read(self.path)
    
    def get(self, section=None, option=None):
        if option is None and section is None:
            return self.getAll()
        elif option is None:
            return self.getSection(section)
        else:
            return self.getOption(section, option)

    def getAll(self):
        data = {}
        for cfg_section in self.cfg.sections():
            data[cfg_section] = {}
            for key, val in self.cfg.items(cfg_section):
                data[cfg_section][key] = val
        return data

    def getSection(self, section):
        data = {}
        for key, val in self.cfg.items(section):
            data[key] = val
        return data

    def getOption(self, section, option):
        return self.cfg.get(section, option)

    def set(self, section, option, value):
        if not self.cfg.has_section(section):
            self.cfg.add_section(section)

        self.cfg.set(section, option, value)
        self.write()

    def sections(self):
        return self.cfg.sections()
        


class DeezerAuth(object):
    urlAuth = 'https://connect.deezer.com/oauth/auth.php?app_id={0}&redirect_uri={1}&perms=basic_access,manage_library'
    urlToken = 'https://connect.deezer.com/oauth/access_token.php?app_id={0}&secret={1}&code={2}&output=json'
    urlRedirect = 'http://localhost:{0}/authfinish'
    urlCheckToken = 'http://api.deezer.com/user/me?access_token={0}'

    def getToken(self):
        return self.token
    
    def setParams(self, params, token=''):
        self.port = int(params['port'])
        self.secret = params['secret']
        self.appId = params['app_id']
        self.token = token

    def setToken(self, token):
        self.token = token

    def authorize(self):
        self.fetchCode()
        self.fetchToken()            

    def fetchCode(self):
        redirect = self.urlRedirect.format(self.port)
        webbrowser.open(self.urlAuth.format(self.appId, redirect))
        self.startServer()
        try:
            while True:
                self.server.handle_request()
        except _Authorization as auth:
            self.code = auth.code

    def startServer(self):
        self.server = _AuthorizationServer('localhost', self.port)

    def fetchToken(self):
        url = self.urlToken.format(self.appId, self.secret, self.code)        
        response = json.loads(requests.get(url).text)

        if 'access_token' in response:
            self.token = response['access_token']
        else:
            raise Exception('Cant get token from deezer')

    def checkToken(self):
        url = self.urlCheckToken.format(self.token)
        response = json.loads(requests.get(url).text)

        if 'error' in response:
            return False
        elif 'type' in response and response['type'] == 'user':
            return True
        else:
            raise Exception('Cant check auth token')

class _AuthorizationServer(http.server.HTTPServer):
    def __init__(self, host, port):
        http.server.HTTPServer.__init__(self, (host, port), _AuthorizationHandler)

    # Disable the default error handling.
    def handle_error(self, request, client_address):
        raise

class _AuthorizationHandler(http.server.BaseHTTPRequestHandler):
    def do_GET(self):
        # Read access_token and use an exception to kill the server listening...
        if self.path.startswith('/authfinish?'):
            self.send_response(200)
            self.send_header('Content-Type', 'text/html')
            self.end_headers()
            self.wfile.write(b'<script>close()</script>Thanks! You may now close this window.')
            raise _Authorization(re.search('code=([^&]+)', self.path).group(1))

        else:
            self.send_error(404)

    # Disable the default logging.
    def log_message(self, format, *args):
        pass

class _Authorization(Exception):
    def __init__(self, code):
        self.code = code

class DeezerTool(object):
    baseUrl = 'http://api.deezer.com'
    limit = 1000

    def __init__(self, config, auth):
        self.config = config
        self.auth = auth
        self.auth.setParams(config.get('auth'), config.get('token', 'token'))

    def checkAndUpdateToken(self):
        if not self.checkToken():
            self.updateToken()
        return self

    def updateToken(self):
        self.auth.authorize()
        self.config.set('token', 'token', self.auth.getToken())
        return self

    def checkToken(self):
        return self.auth.checkToken()

    def getToken(self):
        return self.config.get('token', 'token')

    def processApiError(self, errorData):
        message = errorData['message']
        print('Error '+str(errorData['code'])+': '+message)
        sys.exit()

    def prepareResponse(self, response):
        response = json.loads(response.text)

        if 'error' in response:
            return self.processApiError(response['error'])
        elif 'data' not in response:
            raise Exception('Error occured on request to Deezer api')
        else:
            return response['data']


    def addRequiredParams(self, params):
        if 'access_token' not in params:
            params['access_token'] = self.getToken()
        if 'expires' not in params:
            params['expires'] = 0
        return params


    def apiGet(self, uri, params = {}):
        params = self.addRequiredParams(params)
        response = requests.get(self.baseUrl + uri, params)
        return self.prepareResponse(response)

    def apiPost(self, uri, params={}):
        params = self.addRequiredParams(params)
        response = requests.post(self.baseUrl + uri, params).text
        return self.prepareResponse(response)

    def getPlaylists(self):
        return self.playlists

    def filterPlaylistsByTitle(self, titles):
        self.playlists = [pl for pl in self.playlists if pl['title'] in titles]
        return self

    def findAllPlaylists(self):
        self.playlists = self.apiGet('/user/me/playlists')
        return self


if __name__ == '__main__':
    config = Config(CONFIG_PATH)
    auth = DeezerAuth()

    dTool = DeezerTool(config, auth)

    data = dTool\
        .checkAndUpdateToken()\
        .findAllPlaylists()\
        .filterPlaylistsByTitle(['работа', 'работа 2'])\
        .getPlaylists()

    pp.pprint(data)
    