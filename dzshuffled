#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
author:     yaBoroda
github:     https://github.com/yaboroda/dzshuffled
email:      yarboroda@gmail.com
"""

import configparser
import os
import pprint
import re
import json
import sys
import os
from random import shuffle
import argparse
from typing import Dict, List, Union

import http.server
import webbrowser
import requests

SCRIPT_VERSION = '0.9.1.0'

if 'DZSHUFFLED_CONFIG_PATH' in os.environ:
    CONFIG_PATH = os.environ['DZSHUFFLED_CONFIG_PATH']
else:
    CONFIG_PATH = os.path.expanduser("~") + "/.config/dzshuffled/config.ini"

DEBUG_MODE = False

pp = pprint.PrettyPrinter(indent=4)

class Config(object):
    """
    manage info from config .ini file
    """

    def __init__(self, path):
        """
        path - path to config file
        """

        self.path = path

        if not os.path.isfile(path):
            self.createNewConfigFile()
            print('New config file was created in {}'.format(path))
            sys.exit()
        else:
            self.read()

    def setUpDefaultConfig(self):
        self.cfg['config'] = {'example_config': 'redeclare method setUpDefaultConfig to set up default config'}

    def createNewConfigFile(self):
        os.makedirs(os.path.dirname(self.path), exist_ok=True)
        self.cfg = configparser.ConfigParser()
        self.setUpDefaultConfig()
        self.write()

    def write(self):
        """
        write current config to file
        """

        with open(self.path, 'w') as configfile:
            self.cfg.write(configfile)

    def read(self):
        """
        read config from file, replacing current data
        """

        self.cfg = configparser.ConfigParser()
        self.cfg.read(self.path)
    
    def get(self, section=None, option=None):
        """
        get info from config
        if option is None, will return section as dictionary
        if section is None, will return whole config as dictionary
        """

        if option is None and section is None:
            return self.getAll()
        elif option is None:
            return self.getSection(section)
        else:
            return self.getOption(section, option)

    def getAll(self):
        """
        will return whole config as dictionary
        """

        data = {}
        for cfg_section in self.cfg.sections():
            data[cfg_section] = {}
            for key, val in self.cfg.items(cfg_section):
                data[cfg_section][key] = val
        return data

    def getSection(self, section):
        """
        will return section data as dictionary
        """
        data = {}
        for key, val in self.cfg.items(section):
            data[key] = val
        return data

    def getOption(self, section, option):
        """
        will return value of config option in section
        """
        return self.cfg.get(section, option)

    def set(self, section, option, value):
        """
        set option value and write change to config file
        """
        if not self.cfg.has_section(section):
            self.cfg.add_section(section)

        self.cfg.set(section, option, value)
        self.write()

    def sections(self):
        """
        get list of sections in config
        """
        return self.cfg.sections()


class DeezerConfig(Config):

    def setUpDefaultConfig(self):
        self.cfg['auth'] = {'app_id': '', 'secret': '', 'port': '8090'}
        self.cfg['token'] = {'token': ''}
        self.cfg['pl_example'] = {'title': 'Example shuffled playlist', 'type': 'shuffled', 'source': 'playlist 1, playlist 2', 'limit': 1000}


class DeezerAuth(object):
    urlAuth = 'https://connect.deezer.com/oauth/auth.php?app_id={0}&redirect_uri={1}&perms=basic_access,manage_library,delete_library'
    urlToken = 'https://connect.deezer.com/oauth/access_token.php?app_id={0}&secret={1}&code={2}&output=json'
    urlRedirect = 'http://localhost:{0}/authfinish'
    urlCheckToken = 'http://api.deezer.com/user/me?access_token={0}'
    user = None

    def getToken(self):
        return self.token
    
    def setParams(self, params:Dict, token=''):
        """
        port - on this port will be working web server to recieve auth answer
        secret - secret of your Deezer app
        app_id - id of your Deezer app
        token - auth token, if empty or invalid, it will be fetched
        """
        self.port = int(params['port'])
        self.secret = params['secret']
        self.appId = params['app_id']
        self.token = token

    def setToken(self, token):
        self.token = token

    def authorize(self):
        """
        fetch auth app code, asking you for permission
        then fetch temporary auth token
        """
        if not self.appId or not self.secret:
            raise DeezerAuthException('You cant get authorization token without app_id and secret. Fill it in config file or write there valid token.')
        self.fetchCode()
        self.fetchToken()            

    def fetchCode(self):
        """
        fetch auth app code, asking you for permission
        """
        redirect = self.urlRedirect.format(self.port)
        webbrowser.open(self.urlAuth.format(self.appId, redirect))
        self.startServer()
        try:
            while True:
                self.server.handle_request()
        except _Authorization as auth:
            self.code = auth.code

    def startServer(self):
        """
        start web server to listen for response with auth code
        """
        self.server = _AuthorizationServer('localhost', self.port)

    def fetchToken(self):
        """
        fetch temporary auth token if you has auth code
        """
        url = self.urlToken.format(self.appId, self.secret, self.code)        
        response = json.loads(requests.get(url).text)

        if 'access_token' in response:
            self.token = response['access_token']
        else:
            raise DeezerAuthException('Cant get token from deezer')

    def checkToken(self) -> bool:
        """
        check auth token, fetching user info
        """
        url = self.urlCheckToken.format(self.token)
        response = json.loads(requests.get(url).text)

        if 'error' in response:
            return False
        elif 'type' in response and response['type'] == 'user':
            self.user = response
            return True
        else:
            raise DeezerAuthException('Cant check auth token')

    def fetchUser(self):
        # user fetchig on token check
        if not self.checkToken():
            raise DeezerAuthException('Cant fetch user info due failed token check')

    def getUser(self) -> Dict:
        if self.user is None:
            self.fetchUser()

        return self.user

class _AuthorizationServer(http.server.HTTPServer):
    def __init__(self, host, port):
        http.server.HTTPServer.__init__(self, (host, port), _AuthorizationHandler)

    # Disable the default error handling.
    def handle_error(self, request, client_address):
        raise

class _AuthorizationHandler(http.server.BaseHTTPRequestHandler):
    def do_GET(self):
        # Read access_token and use an exception to kill the server listening...
        if self.path.startswith('/authfinish?'):
            self.send_response(200)
            self.send_header('Content-Type', 'text/html')
            self.end_headers()
            self.wfile.write(b'<script>close()</script>Thanks! You may now close this window.')
            raise _Authorization(re.search('code=([^&]+)', self.path).group(1))

        else:
            self.send_error(404)

    # Disable the default logging.
    def log_message(self, format, *args):
        pass

class DeezerTool(object):
    baseUrl = 'http://api.deezer.com'
    validScenarioTypes = ['shuffled']
    limitTracks = 1000
    limitResultsPerRequest = 500
    limitItemsToDeleteAtOneRequest = 500

    playlists = []
    tracks = []

    def __init__(self, config:DeezerConfig, auth:DeezerAuth):
        self.config = config
        self.auth = auth
        self.auth.setParams(config.get('auth'), config.get('token', 'token'))

    def checkAndUpdateToken(self) -> 'DeezerTool':
        if not self.checkToken():
            self.updateToken()
        return self

    def updateToken(self) -> 'DeezerTool':
        """
        authorize in Deezer and write new token in config file
        """
        self.auth.authorize()

        if self.checkToken():
            self.config.set('token', 'token', self.auth.getToken())
        else:
            raise DeezerToolException('Cant verify new token')

        return self

    def checkToken(self) -> bool:
        return self.auth.checkToken()

    def getToken(self) -> str:
        return self.config.get('token', 'token')

    def processApiError(self, errorData:Dict):
        """
        raise exception by error sesponse from Deezer
        """
        code = errorData['code'] if 'code' in errorData else None
        raise DeezerApiError(errorData['message'], code)

    def prepareResponse(self, response, responseType:str) -> Union[bool, Dict]:
        """
        get data from response object
        responseType - 'list' or 'single'
        if 'list' then getting all paginated data with additional requests
        """
        response = json.loads(response.text)
        
        if isinstance(response, bool):
            return response

        if 'error' in response:
            return self.processApiError(response['error'])

        if responseType == 'list':
            if 'data' not in response:
                raise DeezerToolException('Error occured on request to Deezer api')

            nextPages = []
            if 'next' in response:
                nextPages = self.apiGetStrict(response['next'], 'list')

            return response['data'] + nextPages

        elif responseType == 'single':
            return response

        else:
            raise DeezerToolException('Unknown response type "'+responseType+'", it can be either single or list')
           


    def addRequiredParams(self, params:Dict) -> Dict:
        """
        add token and limit to requests param
        """
        if 'access_token' not in params:
            params['access_token'] = self.getToken()

        if 'limit' not in params:
            params['limit'] = self.limitResultsPerRequest

        return params


    def apiGet(self, uri:str, responseType:str, params:Dict = {}) -> Union[bool, Dict]:
        """
        send GET request to Deezer API
        uri - address without domain
        responseType - 'single' or 'list'
        """
        params = self.addRequiredParams(params)
        response = requests.get(self.baseUrl + uri, params)
        return self.prepareResponse(response, responseType)

    def apiGetStrict(self, url:str, responseType:str) -> Union[bool, Dict]:
        """
        send GET request strictly by url, wich include domain and all parameters
        responseType - 'single' or 'list'
        """
        response = requests.get(url)
        return self.prepareResponse(response, responseType)

    def apiPost(self, uri:str, responseType:str, params:Dict={}) -> Union[bool, Dict]:
        """
        send POST request to Deezer API
        uri - address without domain
        responseType - 'single' or 'list'
        """
        params = self.addRequiredParams(params)
        response = requests.post(self.baseUrl + uri, params)
        return self.prepareResponse(response, responseType)

    def apiDelete(self, uri, responseType, params={}) -> Union[bool, Dict]:
        """
        send DELETE request to Deezer API
        uri - address without domain
        responseType - 'single' or 'list'
        """
        params = self.addRequiredParams(params)
        uri += '?access_token={0}'.format(params.pop('access_token'))

        for p, val in params.items():
            uri += '&{0}={1}'.format(p, val)
        
        response = requests.delete(self.baseUrl + uri)
        return self.prepareResponse(response, responseType)

    def getPlaylists(self) -> List:
        """
        get playlists info stored in self.playlists
        """
        return self.playlists

    def getTracks(self) -> List:
        """
        get tracks info stored in self.tracks
        """
        return self.tracks

    def filterPlaylistsByTitles(self, titles:Union[List, str]) -> 'DeezerTool':
        """
        remove from self.playlisits those which titles does not listed in `titles` param
        """
        if isinstance(titles, str):
            titles = [titles]

        self.playlists = [pl for pl in self.playlists if pl['title'] in titles]
        return self

    def findAllPlaylists(self) -> 'DeezerTool':
        """
        fetch info about all playlists and store it in self.playlists
        """
        self.playlists = self.apiGet('/user/me/playlists', 'list')
        return self

    def findTracksByPlaylists(self) -> 'DeezerTool':
        """
        fetch info about all tracks, listed in playlists from self.playlists
        and store it in self.tracks
        """
        self.tracks = []
        for pl in self.playlists:
            uri = '/playlist/{0}/tracks'.format(pl['id'])
            tracks = self.apiGet(uri, 'list')
            self.tracks += tracks

        return self

    def shuffleTracks(self) -> 'DeezerTool':
        """
        shuffle self.tracks
        """
        shuffle(self.tracks)
        return self

    def filterTracksByLimit(self, limit:int=None) -> 'DeezerTool':
        """
        left only first `limit` items from self.tracks, removing the rest
        if limit is None than limit getting from default value
        """
        if limit is None:
            limit = self.limitTracks

        self.tracks = self.tracks[:limit]
        return self

    def getUser(self) -> Dict:
        """
        get info about current user
        """
        return self.auth.getUser()

    def createPlaylist(self, title:str) -> 'DeezerTool':
        """
        create playlist with title `title` in your Deezer library
        """
        uri = '/user/{0}/playlists'.format(self.getUser()['id'])
        response = self.apiPost(uri, 'single', {'title': title})
        self.newPlaylistId = response['id']
        return self

    def removePlaylistById(self, id) -> 'DeezerTool':
        """
        remove playlist from your library by id
        it will not warning you or ask, so think carefully
        """
        uri = '/playlist/{0}'.format(id)
        response = self.apiDelete(uri, 'single')
        return self

    def purgePlaylistById(self, plId) -> 'DeezerTool':
        """
        remove all tracks from playlist by id
        it will not warning you or ask, so think carefully
        """
        uri = '/playlist/{0}/tracks'.format(plId)
        groups = self.getStringOfIdsByGroups(self.tracks, self.limitItemsToDeleteAtOneRequest)

        for trackIds in groups:
            response = self.apiDelete(uri, 'single', {'songs': trackIds})

    def purgePlaylistByTitle(self, title) -> 'DeezerTool':
        """
        remove all tracks from all playlists with this title
        it will not warning you or ask, so think carefully
        """
        self.findAllPlaylists()\
            .filterPlaylistsByTitles(title)\
            .findTracksByPlaylists()

        for pl in self.playlists:
            self.purgePlaylistById(pl['id'])

    def removePlaylistByTitle(self, title) -> 'DeezerTool':
        """
        remove all playlists from your library with this title
        it will not warning you or ask, so think carefully
        """
        self.findAllPlaylists()
        self.filterPlaylistsByTitles([title])

        for pl in self.playlists:
            self.removePlaylistById(pl['id'])

        self.playlists = []
        return self

    def addTracksToPlaylist(self, plId) -> bool:
        """
        add tracks from self.tracks to playlist with this id
        """
        uri = '/playlist/{0}/tracks'.format(plId)
        trackIds = self.getStringOfIds(self.tracks)
        response = self.apiPost(uri, 'single', {'songs': trackIds})
        return response

    def addTracksToNewPlaylist(self) -> bool:
        """
        add tracks from self.tracks to playlist that was just created
        (it takes id from self.newPlaylistId)
        """
        return self.addTracksToPlaylist(self.newPlaylistId)

    def resetPlaylistByTitle(self, title) -> 'DeezerTool':
        """
        find playlist by title and remove all tracks from it
        if there is several pl with title, it will remove them all and create one new
        if there is no pl with title, it will create one
        cleared or created playlists id will be stored in self.targetPlaylistId
        """

        # find all playlists by title
        self.findAllPlaylists().filterPlaylistsByTitles(title)

        # if there is more then one, remove it and create new
        if len(self.playlists) > 1:
            self.removePlaylistByTitle(title)
            self.createPlaylist(title)
            self.targetPlaylistId = self.newPlaylistId

        # if there is only one, delete all tracks from it
        elif len(self.playlists) == 1:
            self.targetPlaylistId = self.playlists[0]['id']
            self.findTracksByPlaylists()\
                .purgePlaylistById(self.targetPlaylistId)

        # if there is no one, create new
        else:
            self.createPlaylist(title)
            self.targetPlaylistId = self.newPlaylistId

        return self

    def resetShuffledPlaylist(self, title:str, sourcePls:List, limit:int = None) -> 'DeezerTool':
        """
        create playlist with `title`, if it exests then purge it from tracks,
        then populate it from your playlists wich titles listed in `sourcePls`,
        shufflig them before it
        """

        print('Resetting playlist {0}'.format(title))

        # reset playlist and write its id to self.targetPlaylistId
        self.resetPlaylistByTitle(title)

        # find all tracks from list sourcePls, suffle it and cut to limit
        # then shove to target playlist
        self.findAllPlaylists()\
            .filterPlaylistsByTitles(sourcePls)

        print('Finding all tracks from playlists: '+', '.join([pl['title'] for pl in self.playlists]))

        self.findTracksByPlaylists()

        tracksCount = len(self.tracks)
        print('Found {0} tracks'.format(str(tracksCount)))

        self.ridOfDoubleTracks()
        newTracksCount = len(self.tracks)
        tracksCountDelta = tracksCount - newTracksCount

        if tracksCountDelta > 0:
            print('Rid of {0} duplicates, {1} tracks left'.format(tracksCountDelta, newTracksCount))

        print('Shuffling')
        self.shuffleTracks()\
            .filterTracksByLimit(limit)

        print('Adding {0} tracks to playlist {1}'.format(str(len(self.tracks)), title))
        
        self.addTracksToPlaylist(self.targetPlaylistId)

        print('Done')

        return self

    def getStringOfIds(self, itemsList:List[Dict]) -> str:
        """
        get string of id of items in list
        """
        itemsIds = ','.join([ str(item['id']) for item in itemsList ])
        return itemsIds

    def getStringOfIdsByGroups(self, itemsList:List[Dict], limit:int) -> List[str]:
        """
        get list of strings of id of items in list, splitted by `limit` id in string
        """
        groups = []
        for i in range(0, len(itemsList), limit):
            groups.append(self.getStringOfIds( itemsList[i:i+limit] ))

        return groups

    def checkForValidScenarioName(self, scenarioName:str, raiseException = False) -> bool:
        """
        check if scenarioName is valid name for scenario
        if raiseException is True, then instad of returning False it will raise exception
        """
        check = bool(re.search('^pl_', scenarioName))

        if raiseException and not check:
            raise DeezerToolException('Invalid scenario name: "{}"'.format(scenarioName))
        else:
            return check

    def execScenario(self, scenario) -> 'DeezerTool':
        """
        execute scenrio from config by its name
        """
        self.checkForValidScenarioName(scenario, True)
        
        plConfig = self.config.get(scenario)

        if 'type' not in plConfig or not plConfig['type'] or plConfig['type'] not in self.validScenarioTypes:
            raise DeezerToolException('Scenario config section must contain valid type option')

        if 'title' not in plConfig or not plConfig['title']:
            raise DeezerToolException('Scenario config section must contain title option')
        else:
            title = plConfig['title']

        if 'source' not in plConfig or not plConfig['source']:
            raise DeezerToolException('Scenario config section must contain source option')
        else:
            sourcePls = plConfig['source'].split(', ')
        
        limit = int(plConfig['limit']) if 'limit' in plConfig else None

        self.resetShuffledPlaylist(title, sourcePls, limit)

        return self

    def getListOfScenarios(self) -> List:
        """
        get list of scenarios names from config
        """
        scenarios = [key for key, val in self.config.get().items() if self.checkForValidScenarioName(key)]

        return scenarios

    def getScenarioNameByIndex(self, n:int) -> str:
        """
        get scenarios name by it order number in config 
        """
        scenarios = self.getListOfScenarios()
        if len(scenarios) > n:
            return scenarios[n]
        else:
            raise DeezerToolException('There is no scenario number {0}. Max number is {1}'.format(n, len(scenarios)-1))

    def getScenarioIndexByName(self, scenario) -> int:
        """
        get scenario order number by it name
        """
        scenarios = self.getListOfScenarios()
        if scenario in scenarios:
            return scenarios.index(scenario)
        else:
            raise DeezerToolException('There is no scenario "{}"'.format(scenario))

    def getScenarioConfig(self, scenario) -> Dict:
        if self.checkForValidScenarioName(scenario, True):
            return self.config.get(scenario)

    def ridOfDoubleTracks(self) -> 'DeezerTool':
        """
        remove duplicated items from self.tracks
        """
        self.tracks = self.ridOfDoublesInListOfDict(self.tracks)
        return self

    def ridOfDoublesInListOfDict(self, listOfDict:List[Dict], field:str = 'id'):
        """
        remove duplicates from `listOfDict`, comparig them by `field`
        """
        newList = []
        uniqueVals = []

        for el in listOfDict:
            if el[field] not in uniqueVals:
                uniqueVals.append(el[field])
                newList.append(el)

        return newList

class _Authorization(Exception):
    """
    this exception will be raised on successfull authorization
    """
    def __init__(self, code):
        self.code = code

class DeezerApiError(Exception):
    def __init__(self, message, code):
        excMessage = 'Deezer API error {1}: {0}'.format(message, 'code '+str(code) if code else '')
        super(DeezerApiError, self).__init__(excMessage)

class DeezerToolException(Exception):
    pass

class DeezerAuthException(Exception):
    pass

def handleExceptionOutput(e, template='{0}'):
    """
    if not DEBUG_MODE swallow tracing exception, output only message
    """
    if not DEBUG_MODE:
        print(template.format(e))
    else:
        raise e

def printHelpAndExit(parser):
    parser.print_help()
    sys.exit()

def buildCliParser():
    parser = argparse.ArgumentParser(
            description = 'This script will create playlist in your Deezer library consisting of shuffled tracks from your other playlists. Pass scenario name or number to create playlist from it. Pass -l or -lv to see all scenarios. Scenarios sets up in config wich by default in ~/.config/dzshuffled/config.ini but you can reassign it with DZSHUFFLED_CONFIG_PATH environment variable.'
        )

    parser.add_argument('scenario',
            metavar = 'SCENARIO',
            nargs='?', 
            const='', 
            default='',
            help = 'name or number of scenario. Pass -l argument to see full list'
        )

    parser.add_argument('-l', '--list',
            action = 'store_const', 
            const = True,
            help = 'show full list of scenarios to create playlist from, pass -v param to show info about them'
        )

    parser.add_argument('-v', '--verbous',
            action = 'store_const', 
            const = True,
            help = 'if called with argument -l, show info about listed scenarios'
        )

    parser.add_argument('-i', '--info', 
            action = 'store_const', 
            const = True,
            help = 'show info about selected scenario but not do anithing'
        )

    parser.add_argument('--version', 
            action = 'store_const', 
            const = True,
            help = 'show script version'
        )

    return parser

def printInfoAboutScenario(number, name, data = None):
    if data:
        print('[{0}] {1}'.format(number, name))
        pp.pprint(data)
    else:
        print('[{0}] {1}'.format(number, name))

def printListScenarios(dTool, verbosity=None):
    scenarios = dTool.getListOfScenarios()
    for i in range(len(scenarios)):
        if verbosity:
            printInfoAboutScenario(i, scenarios[i], dTool.getScenarioConfig(scenarios[i]))
        else:
            printInfoAboutScenario(i, scenarios[i])

def processCliScenarioCall(scenarioInput, dTool, infoFlag=None):
    if scenarioInput.isnumeric():
        scenarioIndex = int(scenarioInput)
        scenarioName = dTool.getScenarioNameByIndex(scenarioIndex)
    else:
        scenarioName = scenarioInput
        scenarioIndex = dTool.getScenarioIndexByName(scenarioName)

    if args.info:
        printInfoAboutScenario(scenarioIndex, scenarioName, dTool.getScenarioConfig(scenarioName))
    else:
        dTool.checkAndUpdateToken()
        dTool.execScenario(scenarioName)

if __name__ == '__main__':

    # DEBUG_MODE = True

    try:
        config = DeezerConfig(CONFIG_PATH)
        parser = buildCliParser()
        args = parser.parse_args()

        if args.version:
            print('version: {0}'.format(SCRIPT_VERSION))
            sys.exit()

        if not args.scenario and not args.list:
            printHelpAndExit(parser)        

        auth = DeezerAuth()
        dTool = DeezerTool(config, auth)  
        scenariosList = dTool.getListOfScenarios()

        if args.list:
            printListScenarios(dTool, args.verbous)
            sys.exit()

        if args.scenario:
            processCliScenarioCall(args.scenario, dTool, args.info)
            sys.exit()

    except DeezerApiError as e:
        handleExceptionOutput(e)
    except Exception as e:
        handleExceptionOutput(e, 'Error: {0}')