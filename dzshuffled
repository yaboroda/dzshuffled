#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
author:     yaBoroda
github:     https://github.com/yaboroda/dzshuffled
email:      yarboroda@gmail.com
"""

import configparser
import os
import pprint
import re
import json
import sys
import os
from random import shuffle
import argparse

import http.server
import webbrowser
import requests

SCRIPT_VERSION = '0.7.2.0'

if 'DZSHUFFLED_CONFIG_PATH' in os.environ:
    CONFIG_PATH = os.environ['DZSHUFFLED_CONFIG_PATH']
else:
    CONFIG_PATH = os.path.expanduser("~") + "/.config/dzshuffled/config.ini"

DEBUG_MODE = True

pp = pprint.PrettyPrinter(indent=4)

class Config(object):

    def __init__(self, path):
        self.path = path

        if not os.path.isfile(path):
            self.createNewConfigFile()
            print('New config file was created in {}'.format(path))
            sys.exit()
        else:
            self.read()

    def setUpDefaultConfig(self):
        self.cfg['config'] = {'example_config': 'redeclare method setUpDefaultConfig to set up default config'}

    def createNewConfigFile(self):
        os.makedirs(os.path.dirname(self.path), exist_ok=True)
        self.cfg = configparser.ConfigParser()
        self.setUpDefaultConfig()
        self.write()

    def write(self):
        with open(self.path, 'w') as configfile:
            self.cfg.write(configfile)

    def read(self):
        self.cfg = configparser.ConfigParser()
        self.cfg.read(self.path)
    
    def get(self, section=None, option=None):
        if option is None and section is None:
            return self.getAll()
        elif option is None:
            return self.getSection(section)
        else:
            return self.getOption(section, option)

    def getAll(self):
        data = {}
        for cfg_section in self.cfg.sections():
            data[cfg_section] = {}
            for key, val in self.cfg.items(cfg_section):
                data[cfg_section][key] = val
        return data

    def getSection(self, section):
        data = {}
        for key, val in self.cfg.items(section):
            data[key] = val
        return data

    def getOption(self, section, option):
        return self.cfg.get(section, option)

    def set(self, section, option, value):
        if not self.cfg.has_section(section):
            self.cfg.add_section(section)

        self.cfg.set(section, option, value)
        self.write()

    def sections(self):
        return self.cfg.sections()


class DeezerConfig(Config):

    def setUpDefaultConfig(self):
        self.cfg['auth'] = {'app_id': '', 'secret': '', 'port': '8090'}
        self.cfg['token'] = {'token': ''}
        self.cfg['pl_example'] = {'title': 'Example shuffled playlist', 'type': 'shuffled', 'source': 'playlist 1, playlist 2', 'limit': 1000}


class DeezerAuth(object):
    urlAuth = 'https://connect.deezer.com/oauth/auth.php?app_id={0}&redirect_uri={1}&perms=basic_access,manage_library,delete_library'
    urlToken = 'https://connect.deezer.com/oauth/access_token.php?app_id={0}&secret={1}&code={2}&output=json'
    urlRedirect = 'http://localhost:{0}/authfinish'
    urlCheckToken = 'http://api.deezer.com/user/me?access_token={0}'
    user = None

    def getToken(self):
        return self.token
    
    def setParams(self, params, token=''):
        self.port = int(params['port'])
        self.secret = params['secret']
        self.appId = params['app_id']
        self.token = token

    def setToken(self, token):
        self.token = token

    def authorize(self):
        if not self.appId or not self.secret:
            raise DeezerAuthException('You cant get authorization token without app_id and secret. Fill it in config file or write there valid token.')
        self.fetchCode()
        self.fetchToken()            

    def fetchCode(self):
        redirect = self.urlRedirect.format(self.port)
        webbrowser.open(self.urlAuth.format(self.appId, redirect))
        self.startServer()
        try:
            while True:
                self.server.handle_request()
        except _Authorization as auth:
            self.code = auth.code

    def startServer(self):
        self.server = _AuthorizationServer('localhost', self.port)

    def fetchToken(self):
        url = self.urlToken.format(self.appId, self.secret, self.code)        
        response = json.loads(requests.get(url).text)

        if 'access_token' in response:
            self.token = response['access_token']
        else:
            raise DeezerAuthException('Cant get token from deezer')

    def checkToken(self):
        url = self.urlCheckToken.format(self.token)
        response = json.loads(requests.get(url).text)

        if 'error' in response:
            return False
        elif 'type' in response and response['type'] == 'user':
            self.user = response
            return True
        else:
            raise DeezerAuthException('Cant check auth token')

    def fetchUser(self):
        # user fetchig on token check
        if not self.checkToken():
            raise DeezerAuthException('Cant fetch user info due failed token check')

    def getUser(self):
        if self.user is None:
            self.fetchUser()

        return self.user

class _AuthorizationServer(http.server.HTTPServer):
    def __init__(self, host, port):
        http.server.HTTPServer.__init__(self, (host, port), _AuthorizationHandler)

    # Disable the default error handling.
    def handle_error(self, request, client_address):
        raise

class _AuthorizationHandler(http.server.BaseHTTPRequestHandler):
    def do_GET(self):
        # Read access_token and use an exception to kill the server listening...
        if self.path.startswith('/authfinish?'):
            self.send_response(200)
            self.send_header('Content-Type', 'text/html')
            self.end_headers()
            self.wfile.write(b'<script>close()</script>Thanks! You may now close this window.')
            raise _Authorization(re.search('code=([^&]+)', self.path).group(1))

        else:
            self.send_error(404)

    # Disable the default logging.
    def log_message(self, format, *args):
        pass

class DeezerTool(object):
    baseUrl = 'http://api.deezer.com'
    limitTracks = 1000
    limitResultsPerRequest = 500
    limitItemsToDeleteAtOneRequest = 500

    playlists = []
    tracks = []

    def __init__(self, config, auth):
        self.config = config
        self.auth = auth
        self.auth.setParams(config.get('auth'), config.get('token', 'token'))

    def checkAndUpdateToken(self):
        if not self.checkToken():
            self.updateToken()
        return self

    def updateToken(self):
        self.auth.authorize()

        if self.checkToken():
            self.config.set('token', 'token', self.auth.getToken())
        else:
            raise DeezerToolException('Cant verify new token')

        return self

    def checkToken(self):
        return self.auth.checkToken()

    def getToken(self):
        return self.config.get('token', 'token')

    def processApiError(self, errorData):
        code = errorData['code'] if 'code' in errorData else None
        raise DeezerApiError(errorData['message'], code)

    def prepareResponse(self, response, responseType):
        response = json.loads(response.text)
        
        if isinstance(response, bool):
            return response

        if 'error' in response:
            return self.processApiError(response['error'])

        if responseType == 'list':
            if 'data' not in response:
                raise DeezerToolException('Error occured on request to Deezer api')

            nextPages = []
            if 'next' in response:
                nextPages = self.apiGetStrict(response['next'], 'list')

            return response['data'] + nextPages

        elif responseType == 'single':
            return response

        else:
            raise DeezerToolException('Unknown response type "'+responseType+'", it can be one of those: single, list')
           


    def addRequiredParams(self, params):
        if 'access_token' not in params:
            params['access_token'] = self.getToken()

        if 'limit' not in params:
            params['limit'] = self.limitResultsPerRequest

        return params


    def apiGet(self, uri, responseType, params = {}):
        params = self.addRequiredParams(params)
        response = requests.get(self.baseUrl + uri, params)
        return self.prepareResponse(response, responseType)

    def apiGetStrict(self, url, responseType):
        response = requests.get(url)
        return self.prepareResponse(response, responseType)

    def apiPost(self, uri, responseType, params={}):
        params = self.addRequiredParams(params)
        response = requests.post(self.baseUrl + uri, params)
        return self.prepareResponse(response, responseType)

    def apiDelete(self, uri, responseType, params={}):
        params = self.addRequiredParams(params)
        uri += '?access_token={0}'.format(params.pop('access_token'))

        for p, val in params.items():
            uri += '&{0}={1}'.format(p, val)
        
        response = requests.delete(self.baseUrl + uri)
        return self.prepareResponse(response, responseType)

    def getPlaylists(self):
        return self.playlists

    def getTracks(self):
        return self.tracks

    def filterPlaylistsByTitles(self, titles):
        if isinstance(titles, str):
            titles = [titles]

        self.playlists = [pl for pl in self.playlists if pl['title'] in titles]
        return self

    def findAllPlaylists(self):
        self.playlists = self.apiGet('/user/me/playlists', 'list')
        return self

    def findTracksByPlaylists(self):
        self.tracks = []
        for pl in self.playlists:
            uri = '/playlist/{0}/tracks'.format(pl['id'])
            tracks = self.apiGet(uri, 'list')
            self.tracks += tracks

        return self

    def shuffleTracks(self):
        shuffle(self.tracks)
        return self

    def filterTracksByLimit(self, limit=None):
        if limit is None:
            limit = self.limitTracks

        self.tracks = self.tracks[:limit]
        return self

    def getUser(self):
        return self.auth.getUser()

    def createPlaylist(self, title):
        uri = '/user/{0}/playlists'.format(self.getUser()['id'])
        response = self.apiPost(uri, 'single', {'title': title})
        self.newPlaylistId = response['id']
        return self

    def removePlaylistById(self, id):
        uri = '/playlist/{0}'.format(id)
        response = self.apiDelete(uri, 'single')
        return self

    def purgePlaylistById(self, plId):
        uri = '/playlist/{0}/tracks'.format(plId)
        groups = self.getStringOfIdsByGroups(self.tracks, self.limitItemsToDeleteAtOneRequest)

        for trackIds in groups:
            response = self.apiDelete(uri, 'single', {'songs': trackIds})

    def purgePlaylistByTitle(self, title):
        self.findAllPlaylists()\
            .filterPlaylistsByTitles(title)\
            .findTracksByPlaylists()

        for pl in self.playlists:
            self.purgePlaylistById(pl['id'])

    def removePlaylistByTitle(self, title):
        self.findAllPlaylists()
        self.filterPlaylistsByTitles([title])

        for pl in self.playlists:
            self.removePlaylistById(pl['id'])

        self.playlists = []
        return self

    def addTracksToPlaylist(self, plId):
        uri = '/playlist/{0}/tracks'.format(plId)
        trackIds = self.getStringOfIds(self.tracks)
        response = self.apiPost(uri, 'single', {'songs': trackIds})
        return response

    def addTracksToNewPlaylist(self):
        return self.addTracksToPlaylist(self.newPlaylistId)

    def resetPlaylistByTitle(self, title):
        # find all playlists by title
        self.findAllPlaylists().filterPlaylistsByTitles(title)

        # if there is more then one, remove it and create new
        if len(self.playlists) > 1:
            self.removePlaylistByTitle(title)
            self.createPlaylist(title)
            self.targetPlaylistId = self.newPlaylistId

        # if there is only one, delete all tracks from it
        elif len(self.playlists) == 1:
            self.targetPlaylistId = self.playlists[0]['id']
            self.findTracksByPlaylists()\
                .purgePlaylistById(self.targetPlaylistId)

        # if there is no one, create new
        else:
            self.createPlaylist(title)
            self.targetPlaylistId = self.newPlaylistId

        return self

    def resetShuffledPlaylist(self, title, sourcePls, limit = None):

        print('Resetting playlist {0}'.format(title))

        # reset playlist and write its id to self.targetPlaylistId
        self.resetPlaylistByTitle(title)

        # find all tracks from list sourcePls, suffle it and cut to limit
        # then shove to target playlist
        self.findAllPlaylists()\
            .filterPlaylistsByTitles(sourcePls)

        print('Finding all tracks from playlists: '+', '.join([pl['title'] for pl in self.playlists]))

        self.findTracksByPlaylists()

        tracksCount = len(self.tracks)
        print('Found {0} tracks'.format(str(tracksCount)))

        self.ridOfDoubleTracks()
        newTracksCount = len(self.tracks)
        tracksCountDelta = tracksCount - newTracksCount

        if tracksCountDelta > 0:
            print('Rid of {0} duplicates, {1} tracks left'.format(tracksCountDelta, newTracksCount))

        print('Shuffling')
        self.shuffleTracks()\
            .filterTracksByLimit(limit)

        print('Adding {0} tracks to playlist {1}'.format(str(len(self.tracks)), title))
        
        self.addTracksToPlaylist(self.targetPlaylistId)

        print('Done')

        return self

    def getStringOfIds(self, itemsList):
        trackIds = ','.join([ str(item['id']) for item in itemsList ])
        return trackIds

    def getStringOfIdsByGroups(self, itemsList, limit):
        groups = []
        for i in range(0, len(itemsList), limit):
            groups.append(self.getStringOfIds( itemsList[i:i+limit] ))

        return groups

    def checkForValidPlaylistConfigSectionName(self, section):
        return bool(re.search('^pl_', section))

    def doFromConfig(self, section):
        if not self.checkForValidPlaylistConfigSectionName(section):
            raise DeezerToolException('Playlist config section name must begin with pl_')
        
        plConfig = self.config.get(section)

        if 'title' not in plConfig or not plConfig['title']:
            raise DeezerToolException('Playlist config section must contain title option')
        else:
            title = plConfig['title']

        if 'source' not in plConfig or not plConfig['source']:
            raise DeezerToolException('Playlist config section must contain source option')
        else:
            sourcePls = plConfig['source'].split(', ')
        
        limit = int(plConfig['limit']) if 'limit' in plConfig else None

        self.resetShuffledPlaylist(title, sourcePls, limit)

    def getAllPlaylistConfigSections(self):
        sections = [key for key, val in self.config.get().items() if self.checkForValidPlaylistConfigSectionName(key)]

        return sections

    def doFromConfigByNumber(self, n):
        sections = self.getAllPlaylistConfigSections()
        self.doFromConfig(sections[n])

    def ridOfDoubleTracks(self):
        self.tracks = self.ridOfDoublesInListOfDict(self.tracks)

    def ridOfDoublesInListOfDict(self, listOfDict, field = 'id'):
        newList = []
        uniqueVals = []

        for el in listOfDict:
            if el[field] not in uniqueVals:
                uniqueVals.append(el[field])
                newList.append(el)

        return newList

class _Authorization(Exception):
    def __init__(self, code):
        self.code = code

class DeezerApiError(Exception):
    def __init__(self, message, code):
        excMessage = 'Deezer API error {1}: {0}'.format(message, 'code '+str(code) if code else '')
        super(DeezerApiError, self).__init__(excMessage)

class DeezerToolException(Exception):
    pass

class DeezerAuthException(Exception):
    pass

def handleExceptionOutput(e, template='{0}'):
    if not DEBUG_MODE:
        print(template.format(e))
    else:
        raise e

def printHelpAndExit(parser):
    parser.print_help()
    sys.exit()

def buildCliParser():
    parser = argparse.ArgumentParser(
            description = 'This script will create playlist in your Deezer consisting of shuffled tracks from your other playlists. Pass config section name or number to create play list from it. Pass -l or -lv to see all config sections.'
        )

    parser.add_argument('section',
            metavar = 'SECTION',
            nargs='?', 
            const='', 
            default='',
            help = 'name or number of config section. Pass -l argument to see full list'
        )

    parser.add_argument('-l', '--list',
            action = 'store_const', 
            const = True,
            help = 'show full list of config sections to create playlist from, pass -v param to show info about them'
        )

    parser.add_argument('-v', '--verbous',
            action = 'store_const', 
            const = True,
            help = 'if called with argument -l, show info about listed config sections'
        )

    parser.add_argument('-i', '--info', 
            action = 'store_const', 
            const = True,
            help = 'show info about selected config section but not do anithing'
        )

    parser.add_argument('--version', 
            action = 'store_const', 
            const = True,
            help = 'show script version'
        )

    return parser

def printInfoAboutPlaylistConfig(number, name, data = None):
    if data:
        print('[{0}] {1}'.format(number, name))
        pp.pprint(data)
    else:
        print('[{0}] {1}'.format(number, name))

def printListOfPlaylistConfigs(config, sectionsList, verbosity=None):
    for i in range(len(sectionsList)):
        if verbosity:
            printInfoAboutPlaylistConfig(i, sectionsList[i], config.get(sectionsList[i]))
        else:
            printInfoAboutPlaylistConfig(i, sectionsList[i])

def processCliSectionCall(sectionInput, config, sectionsList, dTool, infoFlag=None):
    if sectionInput.isnumeric():
        sectionIndex = int(sectionInput)
        sectionName = sectionsList[sectionIndex]
    else:
        sectionName = sectionInput
        sectionIndex = sectionsList.index(sectionName)

    if args.info:
        printInfoAboutPlaylistConfig(sectionIndex, sectionName, config.get(sectionName))
    else:
        dTool.checkAndUpdateToken()
        dTool.doFromConfig(sectionName)

if __name__ == '__main__':

    # DEBUG_MODE = True

    try:
        config = DeezerConfig(CONFIG_PATH)
        parser = buildCliParser()
        args = parser.parse_args()

        if args.version:
            print('version: {0}'.format(SCRIPT_VERSION))
            sys.exit()

        if not args.section and not args.list:
            printHelpAndExit(parser)        

        auth = DeezerAuth()
        dTool = DeezerTool(config, auth)  
        sectionsList = dTool.getAllPlaylistConfigSections()

        if args.list:
            printListOfPlaylistConfigs(config, sectionsList, args.verbous)
            sys.exit()

        if args.section:
            processCliSectionCall(args.section, config, sectionsList, dTool, args.info)
            sys.exit()

    except DeezerApiError as e:
        handleExceptionOutput(e)
    except Exception as e:
        handleExceptionOutput(e, 'Error: {0}')