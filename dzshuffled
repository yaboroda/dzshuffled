#!/usr/bin/env python3

"""
author:     yaBoroda
github:     https://github.com/yaboroda/dzshuffled
email:      yarboroda@gmail.com
"""

import configparser
import os
import pprint
import re
import json
import sys
from random import shuffle
import argparse
from typing import Dict, List, Union
import http.server
import webbrowser
import requests

SCRIPT_VERSION = '0.9.1.0'
DEBUG_MODE = True
pp = pprint.PrettyPrinter(indent=4)

"""If environment var defined, set CONFIG_PATH from it,
else set to ~/.config/dzshuffled/config.ini
"""
if 'DZSHUFFLED_CONFIG_PATH' in os.environ:
    CONFIG_PATH = os.environ['DZSHUFFLED_CONFIG_PATH']
else:
    CONFIG_PATH = (os.path.expanduser("~")
                   + "/.config/dzshuffled/config.ini")


class Config(object):
    """Manage info from config .ini file."""

    def __init__(self, path: str):
        """Read file from path or create new one.

        Keyword arguments:
        path -- path to config file
        """
        self.path = path

        if not os.path.isfile(path):
            self.create_new_config_file()
            print('New config file was created in {}'.format(path))
            sys.exit()
        else:
            self.read()

    def set_up_default_config(self):
        """Sets up default config data,
        it should be redeclared in subclass.
        """
        self.cfg['config'] = {'example_config': 'example_value'}

    def create_new_config_file(self):
        """Create new config file from default config."""
        os.makedirs(os.path.dirname(self.path), exist_ok=True)
        self.cfg = configparser.ConfigParser()
        self.set_up_default_config()
        self.write()

    def write(self):
        """Write current config to file."""
        with open(self.path, 'w') as configfile:
            self.cfg.write(configfile)

    def read(self):
        """Read config from file, replacing current data."""
        self.cfg = configparser.ConfigParser()
        self.cfg.read(self.path)

    def get(self, section: str = None, option: str = None):
        """Get info from config.

        if option is None, will return section as dictionary
        if section is None, will return whole config as dictionary

        Keyword arguments:
        section -- section name of config (default None)
        option -- option name of config (default None)
        """
        if option is None and section is None:
            return self.get_all()
        elif option is None:
            return self.get_section(section)
        else:
            return self.get_option(section, option)

    def get_all(self):
        """Will return whole config as dictionary."""
        data = {}
        for cfg_section in self.cfg.sections():
            data[cfg_section] = {}
            for key, val in self.cfg.items(cfg_section):
                data[cfg_section][key] = val
        return data

    def get_section(self, section: str) -> Dict:
        """Will return section data as dictionary."""
        data = {}
        for key, val in self.cfg.items(section):
            data[key] = val
        return data

    def get_option(self, section: str, option: str):
        """Will return value of config option in section."""
        return self.cfg.get(section, option)

    def set(self, section: str, option: str, value):
        """Set option value and write change to config file.

        Keyword arguments:
        section -- section name of config (default None)
        option -- option name of config (default None)
        value -- value to put in option
        """
        if not self.cfg.has_section(section):
            self.cfg.add_section(section)

        self.cfg.set(section, option, value)
        self.write()

    def sections(self):
        """Get list of sections in config."""
        return self.cfg.sections()


class DeezerConfig(Config):
    """Config class for DeezerTool object"""

    def set_up_default_config(self):
        """Sets up default config data."""
        self.cfg['auth'] = {
            'app_id': '',
            'secret': '',
            'port': '8090'
        }
        self.cfg['token'] = {
            'token': ''
        }
        self.cfg['pl_example'] = {
            'title': 'Example shuffled playlist',
            'type': 'shuffled',
            'source':
            'playlist 1, playlist 2',
            'limit': 1000
        }


class DeezerAuth(object):
    """Authorization in Deezer.

    1. Fetching auth code for app with asking you for permission
    For getting answer, will be started web server on port from config.

    2. With code fetching temporary auth token. This token you must
    attach with each request to Deezer API
    """

    URL_AUTH = ('https://connect.deezer.com/oauth/auth.php'
                '?app_id={0}&redirect_uri={1}'
                '&perms=basic_access,manage_library,delete_library')
    ULR_TOKEN = ('https://connect.deezer.com/oauth/access_token.php'
                 '?app_id={0}&secret={1}&code={2}&output=json')
    URL_REDIRECT = 'http://localhost:{0}/authfinish'
    URL_CHECK_TOKEN = 'http://api.deezer.com/user/me?access_token={0}'

    def __init__(self):
        self.user = None
        self.token = ''

    def get_token(self):
        return self.token

    def set_params(self, params: Dict, token=''):
        """Set parameters for authorization.

        If you pass in token, it will be used instead of retriving new.

        Keyword arguments:
        params -- dictionary with obligatory keys:
            port - on this port will be started web server
            secret - secret of your Deezer app
            app_id - id of your Deezer app
        token -- auth token, if empty or invalid,
            it will be fetched (default '')
        """
        self.port = int(params['port'])
        self.secret = params['secret']
        self.app_id = params['app_id']
        self.token = token

    def set_token(self, token):
        """Set auth token to use it."""
        self.token = token

    def authorize(self):
        """Authorize and get token."""
        if not self.app_id or not self.secret:
            raise DeezerAuthException(
                'You cant get authorization token without app_id '
                'and secret. Fill it in config file or write there '
                'valid token.'
            )
        self.fetch_code()
        self.fetch_token()

    def fetch_code(self):
        """Fetch auth app code, it will be used to get token."""
        redirect = self.URL_REDIRECT.format(self.port)
        webbrowser.open(self.URL_AUTH.format(self.app_id, redirect))
        self.start_server()
        try:
            while True:
                self.server.handle_request()
        except _Authorization as auth:
            self.code = auth.code

    def start_server(self):
        """Start web server to listen for response with auth code."""
        self.server = _AuthorizationServer('localhost', self.port)

    def fetch_token(self):
        """Fetch temporary auth token if you has auth code."""
        url = self.ULR_TOKEN.format(self.app_id, self.secret, self.code)
        response = json.loads(requests.get(url).text)

        if 'access_token' in response:
            self.token = response['access_token']
        else:
            raise DeezerAuthException('Cant get token from deezer')

    def check_token(self):
        """Check auth token, fetching user info, return bool"""
        url = self.URL_CHECK_TOKEN.format(self.token)
        response = json.loads(requests.get(url).text)

        if 'error' in response:
            return False
        elif 'type' in response and response['type'] == 'user':
            self.user = response
            return True
        else:
            raise DeezerAuthException('Cant check auth token')

    def fetch_user(self):
        """Fetch info about logged in user. It heppens on token check.
        Info stored in self.user
        """
        if not self.check_token():
            raise DeezerAuthException('Cant fetch user info due failed'
                                      ' token check')

    def get_user(self) -> Dict:
        """Return Dict with user info"""
        if self.user is None:
            self.fetch_user()

        return self.user


class _AuthorizationServer(http.server.HTTPServer):

    def __init__(self, host, port):
        http.server.HTTPServer.__init__(self, (host, port),
                                        _AuthorizationHandler)

    def handle_error(self, request, client_address):
        """Disable the default error handling."""
        raise


class _AuthorizationHandler(http.server.BaseHTTPRequestHandler):

    def do_GET(self):
        """Read access_token and use an exception
        to kill the server listening...
        """
        if self.path.startswith('/authfinish?'):
            self.send_response(200)
            self.send_header('Content-Type', 'text/html')
            self.end_headers()
            self.wfile.write(b'<script>close()</script>Thanks!'
                             b' You may now close this window.')
            raise _Authorization(re.search('code=([^&]+)', self.path).group(1))

        else:
            self.send_error(404)

    def log_message(self, format, *args):
        """Disable the default logging."""
        pass


class DeezerTool(object):
    """This class manages playlists in your Deezer library.
    All actions related only to playlists and tracks, that added to it
    """

    BASE_URL = 'http://api.deezer.com'
    VALID_SCENARIO_TYPES = ['shuffled']
    LIMIT_TRACKS = 1000
    LIMIT_RESULTS_PER_REQUEST = 500
    LIMIT_ITEMS_DELETE_PER_ONE_REQUEST = 500

    def __init__(self, config: DeezerConfig, auth: DeezerAuth):
        self.playlists = []
        self.tracks = []
        self.config = config
        self.auth = auth
        self.auth.set_params(config.get('auth'),
                             config.get('token', 'token'))

    def check_and_update_token(self):
        """Check auth token and update it if not valid."""
        if not self.check_token():
            self.update_token()
        return self

    def update_token(self):
        """Authorize in Deezer and write new token in config file."""
        self.auth.authorize()

        if self.check_token():
            self.config.set('token', 'token', self.auth.get_token())
        else:
            raise DeezerToolException('Cant verify new token')

        return self

    def check_token(self):
        """Check current auth token, return bool."""
        return self.auth.check_token()

    def get_token(self):
        """Get current auth token. Return str."""
        return self.config.get('token', 'token')

    def process_api_error(self, error_data: Dict):
        """Raise exception by error sesponse from Deezer.

        Keyword arguments:
        error_data -- Dict with info about errror with keys:
            'message' - error message, str
            'code'    - error code, optional, str
        """
        code = error_data['code'] if 'code' in error_data else None
        raise DeezerApiError(error_data['message'], code)

    def prepare_response(self, response, response_type: str):
        """Get data from response object.

        Keyword arguments:
        response -- response object from requests lib
        response_type -- 'list' or 'single'
        if 'list' then getting all paginated data with additional requests
        """
        response = json.loads(response.text)

        if isinstance(response, bool):
            return response

        if 'error' in response:
            return self.process_api_error(response['error'])

        if response_type == 'list':
            if 'data' not in response:
                raise DeezerToolException('Error occured on request'
                                          ' to Deezer api')

            nextPages = []
            if 'next' in response:
                nextPages = self.api_get_strict(response['next'], 'list')

            return response['data'] + nextPages

        elif response_type == 'single':
            return response

        else:
            raise DeezerToolException(
                'Unknown response type "{0}",'
                ' it can be either single or list'.format(response_type)
            )

    def add_required_params(self, params: Dict):
        """Add token and limit to requests param. Return Dict"""
        if 'access_token' not in params:
            params['access_token'] = self.get_token()

        if 'limit' not in params:
            params['limit'] = self.LIMIT_RESULTS_PER_REQUEST

        return params

    def api_get(self, uri: str, response_type: str, params: Dict = {}):
        """Send GET request to Deezer API, return Dict or bool

        Keyword arguments:
        uri -- address without domain
        response_type -- 'single' or 'list'
        params -- Dict with parameters to add to request (default {})
        """
        params = self.add_required_params(params)
        response = requests.get(self.BASE_URL + uri, params)
        return self.prepare_response(response, response_type)

    def api_get_strict(self, url: str, response_type: str):
        """Send GET request strictly by url, return bool or Dict

        Url include domain and all parameters
        response_type -- 'single' or 'list'
        """
        response = requests.get(url)
        return self.prepare_response(response, response_type)

    def api_post(self, uri: str, response_type: str, params: Dict = {}):
        """Send POST request to Deezer API, return bool or Dict.

        Keyword arguments:
        uri -- address without domain
        response_type -- 'single' or 'list'
        params -- Dict with parameters to add to request (default {})
        """
        params = self.add_required_params(params)
        response = requests.post(self.BASE_URL + uri, params)
        return self.prepare_response(response, response_type)

    def api_delete(self, uri: str, response_type: str, params: Dict = {}):
        """Send DELETE request to Deezer API, return bool or Dict.

        Keyword arguments:
        uri -- address without domain
        response_type -- 'single' or 'list'
        params -- Dict with parameters to add to request (default {})
        """
        params = self.add_required_params(params)
        uri += '?access_token={0}'.format(params.pop('access_token'))

        for p, val in params.items():
            uri += '&{0}={1}'.format(p, val)

        response = requests.delete(self.BASE_URL + uri)
        return self.prepare_response(response, response_type)

    def get_playlists(self) -> List:
        """Get playlists info stored in self.playlists."""
        return self.playlists

    def get_tracks(self) -> List:
        """Get tracks info stored in self.tracks."""
        return self.tracks

    def filter_playlists_by_titles(self, titles: Union[List, str]):
        """Remove from self.playlisits those items
        which titles does not listed in `titles` param.
        """
        if isinstance(titles, str):
            titles = [titles]

        self.playlists = [pl for pl in self.playlists if pl['title'] in titles]
        return self

    def find_all_play_lists(self):
        """Fetch info about all playlists and store it in self.playlists."""
        self.playlists = self.api_get('/user/me/playlists', 'list')
        return self

    def find_tracks_by_playlists(self):
        """Fetch info about all tracks, listed in playlists from
        self.playlists and store it in self.tracks.
        """
        self.tracks = []
        for pl in self.playlists:
            uri = '/playlist/{0}/tracks'.format(pl['id'])
            tracks = self.api_get(uri, 'list')
            self.tracks += tracks

        return self

    def shuffle_tracks(self):
        """Shuffle self.tracks."""
        shuffle(self.tracks)
        return self

    def filter_tracks_by_limit(self, limit: int = None):
        """Left only first `limit` items from self.tracks,
        removing the rest. If limit is None
        than limit getting from self.LIMIT_TRACKS.
        """
        if limit is None:
            limit = self.LIMIT_TRACKS

        self.tracks = self.tracks[:limit]
        return self

    def get_user(self):
        """Get info about current user, return Dict."""
        return self.auth.get_user()

    def create_playlist(self, title: str):
        """Create playlist with title in your Deezer library."""
        uri = '/user/{0}/playlists'.format(self.get_user()['id'])
        response = self.api_post(uri, 'single', {'title': title})
        self.new_playlist_id = response['id']
        return self

    def remove_playlist_by_id(self, id):
        """Remove playlist from your library by id.

        It will not warning you or ask, so think carefully
        """
        uri = '/playlist/{0}'.format(id)
        self.api_delete(uri, 'single')
        return self

    def purge_playlist_by_id(self, id):
        """Remove all tracks from playlist by id.

        It will not warning you or ask, so think carefully.
        """
        uri = '/playlist/{0}/tracks'.format(id)
        groups = self.get_string_of_ids_by_groups(
            self.tracks,
            self.LIMIT_ITEMS_DELETE_PER_ONE_REQUEST
        )

        for track_ids in groups:
            self.api_delete(uri, 'single', {'songs': track_ids})

    def purge_playlist_by_title(self, title):
        """Remove all tracks from all playlists with this title.

        It will not warning you or ask, so think carefully
        """
        (self.find_all_play_lists()
            .filter_playlists_by_titles(title)
            .find_tracks_by_playlists())

        for pl in self.playlists:
            self.purge_playlist_by_id(pl['id'])

    def remove_playlist_by_title(self, title: str):
        """Remove all playlists from your library with this title.

        It will not warning you or ask, so think carefully
        """
        self.find_all_play_lists()
        self.filter_playlists_by_titles([title])

        for pl in self.playlists:
            self.remove_playlist_by_id(pl['id'])

        self.playlists = []
        return self

    def add_tracks_to_playlist(self, id):
        """Add tracks from self.tracks to playlist with this id,
        return bool.
        """
        uri = '/playlist/{0}/tracks'.format(id)
        track_ids = self.get_string_of_ids(self.tracks)
        response = self.api_post(uri, 'single', {'songs': track_ids})
        return response

    def add_tracks_to_new_playlist(self) -> bool:
        """Add tracks from self.tracks to playlist that was just created.

        (it takes id from self.new_playlist_id)
        """
        return self.add_tracks_to_playlist(self.new_playlist_id)

    def reset_playlist_by_title(self, title):
        """Find playlist by title and remove all tracks from it.

        If there is several pl with title, it will remove them all
        and create one new.
        If there is no pl with title, it will create one.
        Cleared or created playlists id will be stored
        in self.target_playlist_id
        """

        # find all playlists by title
        self.find_all_play_lists().filter_playlists_by_titles(title)

        # if there is more then one, remove it and create new
        if len(self.playlists) > 1:
            self.remove_playlist_by_title(title)
            self.create_playlist(title)
            self.target_playlist_id = self.new_playlist_id

        # if there is only one, delete all tracks from it
        elif len(self.playlists) == 1:
            self.target_playlist_id = self.playlists[0]['id']
            self.find_tracks_by_playlists()
            self.purge_playlist_by_id(self.target_playlist_id)

        # if there is no one, create new
        else:
            self.create_playlist(title)
            self.target_playlist_id = self.new_playlist_id

        return self

    def reset_shuffled_playlist(self, title: str, source_pls: List,
                                limit: int = None):
        """Create shuffled playlist with `title`.

        If it exests then purge it from tracks,
        then populate it from your playlists wich titles listed
        in `source_pls`, shufflig them before it
        """

        print('Resetting playlist {0}'.format(title))

        # reset playlist and write its id to self.target_playlist_id
        self.reset_playlist_by_title(title)

        # find all tracks from list source_pls,
        # suffle it and cut to limit, then shove to target playlist
        self.find_all_play_lists()
        self.filter_playlists_by_titles(source_pls)

        print('Finding all tracks from playlists: '
              + ', '.join([pl['title'] for pl in self.playlists]))

        self.find_tracks_by_playlists()

        tracks_count = len(self.tracks)
        print('Found {0} tracks'.format(str(tracks_count)))

        self.rid_of_double_tracks()
        new_tracks_count = len(self.tracks)
        tracks_count_delta = tracks_count - new_tracks_count

        if tracks_count_delta > 0:
            print('Rid of {0} duplicates, {1} tracks left'
                  .format(tracks_count_delta, new_tracks_count))

        print('Shuffling')
        self.shuffle_tracks()
        self.filter_tracks_by_limit(limit)

        print('Adding {0} tracks to playlist {1}'
              .format(str(len(self.tracks)), title))

        self.add_tracks_to_playlist(self.target_playlist_id)

        print('Done')

        return self

    def get_string_of_ids(self, items_list: List[Dict]):
        """Get string of id of items in list."""
        items_ids = ','.join([str(item['id']) for item in items_list])
        return items_ids

    def get_string_of_ids_by_groups(self, items_list: List[Dict], limit: int):
        """Get list of strings of id of items in list,
        splitted by limit in each string, return List of str
        """
        groups = []
        for i in range(0, len(items_list), limit):
            groups.append(self.get_string_of_ids(items_list[i:i+limit]))

        return groups

    def check_scenario_name_valid(self, scenario_name: str,
                                  raise_exception: bool = False):
        """Check if scenario_name is valid name for scenario, return bool

        If raise_exception is True, then instad of returning False
        it will raise exception.
        """
        check = bool(re.search('^pl_', scenario_name))

        if raise_exception and not check:
            raise DeezerToolException('Invalid scenario name: "{}"'
                                      .format(scenario_name))
        else:
            return check

    def exec_scenario(self, scenario):
        """Execute scenrio from config by its name."""
        self.check_scenario_name_valid(scenario, True)

        scenario_config = self.config.get(scenario)

        if 'type' not in scenario_config or not scenario_config['type'] \
                or scenario_config['type'] not in self.VALID_SCENARIO_TYPES:
            raise DeezerToolException('Scenario config section must'
                                      ' contain valid type option')

        if 'title' not in scenario_config or not scenario_config['title']:
            raise DeezerToolException('Scenario config section must'
                                      ' contain title option')
        else:
            title = scenario_config['title']

        if 'source' not in scenario_config or not scenario_config['source']:
            raise DeezerToolException('Scenario config section must'
                                      ' contain source option')
        else:
            source_pls = scenario_config['source'].split(', ')

        if 'limit' in scenario_config:
            limit = int(scenario_config['limit'])
        else:
            limit = None

        self.reset_shuffled_playlist(title, source_pls, limit)

        return self

    def get_list_of_scenarios(self):
        """Get list of scenarios names from config, return List of str"""
        scenarios = [key for key, val in self.config.get().items()
                     if self.check_scenario_name_valid(key)]

        return scenarios

    def get_scenario_name_by_index(self, n: int):
        """Get scenarios name by it order number in config, return str"""
        scenarios = self.get_list_of_scenarios()
        if len(scenarios) > n:
            return scenarios[n]
        else:
            raise DeezerToolException(
                'There is no scenario number {0}. Max number is {1}'
                .format(n, len(scenarios)-1)
            )

    def get_scenario_index_by_name(self, scenario):
        """Get scenario order number by it name, return int."""
        scenarios = self.get_list_of_scenarios()
        if scenario in scenarios:
            return scenarios.index(scenario)
        else:
            raise DeezerToolException('There is no scenario "{0}"'
                                      .format(scenario))

    def get_scenario_config(self, scenario: str):
        """Get scenario config, return Dict."""
        if self.check_scenario_name_valid(scenario, True):
            return self.config.get(scenario)

    def rid_of_double_tracks(self):
        """Remove duplicated items from self.tracks."""
        self.tracks = self.rid_of_doubles_in_list_of_dict(self.tracks)
        return self

    def rid_of_doubles_in_list_of_dict(self, list_of_dict: List[Dict],
                                       field: str = 'id'):
        """Remove duplicates from list_of_dict,
        comparig them by field argument.
        """
        new_list = []
        unique_vals = []

        for el in list_of_dict:
            if el[field] not in unique_vals:
                unique_vals.append(el[field])
                new_list.append(el)

        return new_list


class _Authorization(Exception):
    """
    this exception will be raised on successfull authorization
    """
    def __init__(self, code):
        self.code = code


class DeezerApiError(Exception):
    def __init__(self, message, code):
        codeStr = 'code '+str(code) if code else ''
        exc_message = 'Deezer API error {1}: {0}'.format(message, codeStr)
        super(DeezerApiError, self).__init__(exc_message)


class DeezerToolException(Exception):
    pass


class DeezerAuthException(Exception):
    pass


def handle_exception_output(e, template='{0}'):
    """If not DEBUG_MODE swallow tracing exception, output only message."""
    if not DEBUG_MODE:
        print(template.format(e))
    else:
        raise e


def print_help_and_exit(parser):
    parser.print_help()
    sys.exit()


def build_cli_parser():
    parser = argparse.ArgumentParser(
        description='This script will create playlist in your Deezer'
                    ' library consisting of shuffled tracks from your'
                    ' other playlists. Pass scenario name or number to'
                    ' create playlist from it. Pass -l or -lv to see'
                    ' all scenarios. Scenarios sets up in config wich'
                    ' by default in ~/.config/dzshuffled/config.ini but'
                    ' you can reassign it with DZSHUFFLED_CONFIG_PATH'
                    ' environment variable.'
    )

    parser.add_argument(
        'scenario',
        metavar='SCENARIO',
        nargs='?',
        const='',
        default='',
        help='name or number of scenario. Pass -l argument to see full list'
    )

    parser.add_argument(
        '-l', '--list',
        action='store_const',
        const=True,
        help='show full list of scenarios to create playlist from,'
             ' pass -v param to show info about them'
    )

    parser.add_argument(
        '-v', '--verbous',
        action='store_const',
        const=True,
        help='if called with argument -l, show info about listed scenarios'
    )

    parser.add_argument(
        '-i', '--info',
        action='store_const',
        const=True,
        help='show info about selected scenario but not do anithing'
    )

    parser.add_argument(
        '--version',
        action='store_const',
        const=True,
        help='show script version'
    )

    return parser


def print_info_about_scenario(number, name, data=None):
    if data:
        print('[{0}] {1}'.format(number, name))
        pp.pprint(data)
    else:
        print('[{0}] {1}'.format(number, name))


def print_list_scenarios(dz_tool, verbosity=None):
    scenarios = dz_tool.get_list_of_scenarios()
    for i in range(len(scenarios)):
        if verbosity:
            print_info_about_scenario(
                i, scenarios[i], dz_tool.get_scenario_config(scenarios[i])
            )
        else:
            print_info_about_scenario(i, scenarios[i])


def process_cli_scenario_call(scenario_input, dz_tool, info_flag=None):
    if scenario_input.isnumeric():
        scenario_index = int(scenario_input)
        scenario_name = dz_tool.get_scenario_name_by_index(scenario_index)
    else:
        scenario_name = scenario_input
        scenario_index = dz_tool.get_scenario_index_by_name(scenario_name)

    if info_flag:
        print_info_about_scenario(
            scenario_index, scenario_name,
            dz_tool.get_scenario_config(scenario_name)
        )
    else:
        dz_tool.check_and_update_token()
        dz_tool.exec_scenario(scenario_name)


if __name__ == '__main__':

    # DEBUG_MODE = True

    try:
        config = DeezerConfig(CONFIG_PATH)
        parser = build_cli_parser()
        args = parser.parse_args()

        if args.version:
            print('version: {0}'.format(SCRIPT_VERSION))
            sys.exit()

        if not args.scenario and not args.list:
            print_help_and_exit(parser)

        auth = DeezerAuth()
        dz_tool = DeezerTool(config, auth)

        if args.list:
            print_list_scenarios(dz_tool, args.verbous)
            sys.exit()

        if args.scenario:
            process_cli_scenario_call(args.scenario, dz_tool, args.info)
            sys.exit()

    except DeezerApiError as e:
        handle_exception_output(e)
    except Exception as e:
        handle_exception_output(e, 'Error: {0}')
